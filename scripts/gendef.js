#!/usr/bin/env node

const fs = require("fs").promises;
const path = require("path");
const cheerio = require("cheerio");
const axios = require("axios");
const _ = require("lodash");
const compileFromFile = require("json-schema-to-typescript").compileFromFile;

const parseKeycloakAdminDoc = async keycloakVersion => {
  const resp = await axios.get(
    `https://www.keycloak.org/docs-api/${keycloakVersion}/rest-api/index.html`,
    { responseType: "text" }
  );
  const $ = cheerio.load(resp.data);

  const definitions = parseDefinitions($);
  const schemas = definitions.map(definitionToSchema);
  const schemasDir = path.join(__dirname, "..", "schemas");
  const tsDir = path.join(__dirname, "..", "src", "definitions");
  await fs.rm(schemasDir, { force: true, recursive: true });
  await fs.mkdir(schemasDir, { recursive: true });
  await fs.rm(tsDir, { force: true, recursive: true });
  await fs.mkdir(tsDir, { recursive: true });
  await saveSchemasToFiles(schemasDir, schemas);
  await compileSchemas(schemasDir, tsDir, schemas);
};

const parseDefinitions = $ => {
  const defsSubsection = $("#_definitions").next();

  const definitions = [];
  for (let node of defsSubsection.children(".sect2")) {
    const el = $(node);
    const h3 = el.find("h3");
    const defID = h3.attr("id");
    const defName = h3.text().trim();
    const schemaCol = el
      .find("tr > td:nth-child(2) > p")
      .toArray()
      .map(el => ({
        type: $(el).text(),
        link: $(el)
          .find("a")
          .attr("href")
      }));
    const columns = el
      .find("tr > td:first-child")
      .toArray()
      .map((el, i) => ({
        name: $(el)
          .find("p > strong")
          .text(),
        optional:
          $(el)
            .find("em")
            .text() === "optional",
        ...schemaCol[i]
      }));
    definitions.push({ defID, defName, columns });
  }
  return definitions;
};

const schemaType = type => {
  let m = type.match(/^(string|boolean)$/);
  if (m !== null) {
    return { type: type };
  }

  m = type.match(/^integer\(int\d{2}\)$/);
  if (m !== null) {
    return { type: "integer" };
  }

  m = type.match(/^number\(float\)$/);
  if (m !== null) {
    return { type: "number" };
  }

  m = type.match(/^(Map|Object)$/);
  if (m !== null) {
    return { type: "object", additionalProperties: { type: "string" } };
  }

  m = type.match(/^(\w+)-(\w+)$/);
  if (m !== null) {
    return { $ref: `${m[1]}${m[2]}.json` };
  }

  m = type.match(/^[A-Z]\w+$/);
  if (m !== null) {
    return { $ref: `${type}.json` };
  }

  m = type.match(/^<\s+(.+)\s+>\s+array$/);
  if (m !== null) {
    return { type: "array", items: schemaType(m[1].trim()) };
  }

  m = type.match(/^enum\s+\((.+)\)$/);
  if (m !== null) {
    return { type: "string", enum: m[1].split(",").map(s => s.trim()) };
  }

  throw new Error(`unparsable type ${type}`);
};

const columnToSchema = col => {
  return schemaType(col.type.trim());
};

const definitionToSchema = def => {
  return {
    title: def.defName.replace("-", ""),
    type: "object",
    properties: _.fromPairs(
      def.columns.map(col => [col.name, columnToSchema(col)])
    ),
    additionalProperties: false,
    required: def.columns.filter(col => !col.optional).map(col => col.name)
  };
};

const saveSchemasToFiles = async (schemasDir, schemas) =>
  Promise.all(
    schemas.map(schema =>
      fs.writeFile(
        path.join(schemasDir, `${schema.title}.json`),
        JSON.stringify(schema, null, 2)
      )
    )
  );

const bannerComment = [
  "/* eslint-disable */",
  "/**",
  "* This file was automatically generated by `npm run gendef`.",
  "* DO NOT MODIFY IT BY HAND. Instead, update the script gendef within package.json,",
  "* and run `npm run gendef` to regenerate this file.",
  "*/"
].join("\n");

const compileSchemas = async (schemasDir, tsDir, schemas) =>
  Promise.all(
    schemas.map(schema =>
      compileFromFile(path.join(schemasDir, `${schema.title}.json`), {
        cwd: path.join(__dirname, "..", "schemas"),
        bannerComment
      }).then(ts => fs.writeFile(path.join(tsDir, `${schema.title}.d.ts`), ts))
    )
  );

parseKeycloakAdminDoc(process.argv[process.argv.length - 1]);
