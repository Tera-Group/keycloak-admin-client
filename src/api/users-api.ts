/* tslint:disable */
/* eslint-disable */
/**
 * Keycloak Admin REST API
 * This is a REST API reference for the Keycloak Admin REST API.
 *
 * The version of the OpenAPI document: 1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from '../common';
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from '../base';
// @ts-ignore
import { CredentialRepresentation } from '../model';
// @ts-ignore
import { FederatedIdentityRepresentation } from '../model';
// @ts-ignore
import { UserRepresentation } from '../model';
/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Returns the number of users that match the given criteria.
     * @param {string} realm realm name (not id!)
     * @param {string} [email] email filter
     * @param {boolean} [emailVerified]
     * @param {boolean} [enabled] Boolean representing if user is enabled or not
     * @param {string} [firstName] first name filter
     * @param {string} [lastName] last name filter
     * @param {string} [search] arbitrary search string for all the fields below
     * @param {string} [username] username filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersCountGet: async (
      realm: string,
      email?: string,
      emailVerified?: boolean,
      enabled?: boolean,
      firstName?: string,
      lastName?: string,
      search?: string,
      username?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmUsersCountGet', 'realm', realm);
      const localVarPath = `/{realm}/users/count`.replace(
        `{${'realm'}}`,
        encodeURIComponent(String(realm))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (email !== undefined) {
        localVarQueryParameter['email'] = email;
      }

      if (emailVerified !== undefined) {
        localVarQueryParameter['emailVerified'] = emailVerified;
      }

      if (enabled !== undefined) {
        localVarQueryParameter['enabled'] = enabled;
      }

      if (firstName !== undefined) {
        localVarQueryParameter['firstName'] = firstName;
      }

      if (lastName !== undefined) {
        localVarQueryParameter['lastName'] = lastName;
      }

      if (search !== undefined) {
        localVarQueryParameter['search'] = search;
      }

      if (username !== undefined) {
        localVarQueryParameter['username'] = username;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get users   Returns a stream of users, filtered according to query parameters.
     * @param {string} realm realm name (not id!)
     * @param {boolean} [briefRepresentation] Boolean which defines whether brief representations are returned (default: false)
     * @param {string} [email] A String contained in email, or the complete email, if param \&quot;exact\&quot; is true
     * @param {boolean} [emailVerified] whether the email has been verified
     * @param {boolean} [enabled] Boolean representing if user is enabled or not
     * @param {boolean} [exact] Boolean which defines whether the params \&quot;last\&quot;, \&quot;first\&quot;, \&quot;email\&quot; and \&quot;username\&quot; must match exactly
     * @param {number} [first] Pagination offset
     * @param {string} [firstName] A String contained in firstName, or the complete firstName, if param \&quot;exact\&quot; is true
     * @param {string} [idpAlias] The alias of an Identity Provider linked to the user
     * @param {string} [idpUserId] The userId at an Identity Provider linked to the user
     * @param {string} [lastName] A String contained in lastName, or the complete lastName, if param \&quot;exact\&quot; is true
     * @param {number} [max] Maximum results size (defaults to 100)
     * @param {string} [q] A query to search for custom attributes, in the format \&#39;key1:value2 key2:value2\&#39;
     * @param {string} [search] A String contained in username, first or last name, or email
     * @param {string} [username] A String contained in username, or the complete username, if param \&quot;exact\&quot; is true
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersGet: async (
      realm: string,
      briefRepresentation?: boolean,
      email?: string,
      emailVerified?: boolean,
      enabled?: boolean,
      exact?: boolean,
      first?: number,
      firstName?: string,
      idpAlias?: string,
      idpUserId?: string,
      lastName?: string,
      max?: number,
      q?: string,
      search?: string,
      username?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmUsersGet', 'realm', realm);
      const localVarPath = `/{realm}/users`.replace(
        `{${'realm'}}`,
        encodeURIComponent(String(realm))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (briefRepresentation !== undefined) {
        localVarQueryParameter['briefRepresentation'] = briefRepresentation;
      }

      if (email !== undefined) {
        localVarQueryParameter['email'] = email;
      }

      if (emailVerified !== undefined) {
        localVarQueryParameter['emailVerified'] = emailVerified;
      }

      if (enabled !== undefined) {
        localVarQueryParameter['enabled'] = enabled;
      }

      if (exact !== undefined) {
        localVarQueryParameter['exact'] = exact;
      }

      if (first !== undefined) {
        localVarQueryParameter['first'] = first;
      }

      if (firstName !== undefined) {
        localVarQueryParameter['firstName'] = firstName;
      }

      if (idpAlias !== undefined) {
        localVarQueryParameter['idpAlias'] = idpAlias;
      }

      if (idpUserId !== undefined) {
        localVarQueryParameter['idpUserId'] = idpUserId;
      }

      if (lastName !== undefined) {
        localVarQueryParameter['lastName'] = lastName;
      }

      if (max !== undefined) {
        localVarQueryParameter['max'] = max;
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q;
      }

      if (search !== undefined) {
        localVarQueryParameter['search'] = search;
      }

      if (username !== undefined) {
        localVarQueryParameter['username'] = username;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Return credential types, which are provided by the user storage where user is stored.
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdConfiguredUserStorageCredentialTypesGet: async (
      realm: string,
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmUsersIdConfiguredUserStorageCredentialTypesGet',
        'realm',
        realm
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists(
        'realmUsersIdConfiguredUserStorageCredentialTypesGet',
        'id',
        id
      );
      const localVarPath =
        `/{realm}/users/{id}/configured-user-storage-credential-types`
          .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
          .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Revoke consent and offline tokens for particular client from user
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {string} client Client id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdConsentsClientDelete: async (
      realm: string,
      id: string,
      client: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmUsersIdConsentsClientDelete', 'realm', realm);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmUsersIdConsentsClientDelete', 'id', id);
      // verify required parameter 'client' is not null or undefined
      assertParamExists('realmUsersIdConsentsClientDelete', 'client', client);
      const localVarPath = `/{realm}/users/{id}/consents/{client}`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
        .replace(`{${'client'}}`, encodeURIComponent(String(client)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get consents granted by the user
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdConsentsGet: async (
      realm: string,
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmUsersIdConsentsGet', 'realm', realm);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmUsersIdConsentsGet', 'id', id);
      const localVarPath = `/{realm}/users/{id}/consents`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Remove a credential for a user
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {string} credentialId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdCredentialsCredentialIdDelete: async (
      realm: string,
      id: string,
      credentialId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmUsersIdCredentialsCredentialIdDelete',
        'realm',
        realm
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmUsersIdCredentialsCredentialIdDelete', 'id', id);
      // verify required parameter 'credentialId' is not null or undefined
      assertParamExists(
        'realmUsersIdCredentialsCredentialIdDelete',
        'credentialId',
        credentialId
      );
      const localVarPath = `/{realm}/users/{id}/credentials/{credentialId}`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
        .replace(
          `{${'credentialId'}}`,
          encodeURIComponent(String(credentialId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Move a credential to a position behind another credential
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {string} credentialId The credential to move
     * @param {string} newPreviousCredentialId The credential that will be the previous element in the list. If set to null, the moved credential will be the first element in the list.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPost:
      async (
        realm: string,
        id: string,
        credentialId: string,
        newPreviousCredentialId: string,
        options: AxiosRequestConfig = {}
      ): Promise<RequestArgs> => {
        // verify required parameter 'realm' is not null or undefined
        assertParamExists(
          'realmUsersIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPost',
          'realm',
          realm
        );
        // verify required parameter 'id' is not null or undefined
        assertParamExists(
          'realmUsersIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPost',
          'id',
          id
        );
        // verify required parameter 'credentialId' is not null or undefined
        assertParamExists(
          'realmUsersIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPost',
          'credentialId',
          credentialId
        );
        // verify required parameter 'newPreviousCredentialId' is not null or undefined
        assertParamExists(
          'realmUsersIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPost',
          'newPreviousCredentialId',
          newPreviousCredentialId
        );
        const localVarPath =
          `/{realm}/users/{id}/credentials/{credentialId}/moveAfter/{newPreviousCredentialId}`
            .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
            .replace(`{${'id'}}`, encodeURIComponent(String(id)))
            .replace(
              `{${'credentialId'}}`,
              encodeURIComponent(String(credentialId))
            )
            .replace(
              `{${'newPreviousCredentialId'}}`,
              encodeURIComponent(String(newPreviousCredentialId))
            );
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = {
          method: 'POST',
          ...baseOptions,
          ...options,
        };
        const localVarHeaderParameter = {} as any;
        const localVarQueryParameter = {} as any;

        // authentication access_token required
        // http bearer authentication required
        await setBearerAuthToObject(localVarHeaderParameter, configuration);

        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = {
          ...localVarHeaderParameter,
          ...headersFromBaseOptions,
          ...options.headers,
        };

        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions,
        };
      },
    /**
     *
     * @summary Move a credential to a first position in the credentials list of the user
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {string} credentialId The credential to move
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdCredentialsCredentialIdMoveToFirstPost: async (
      realm: string,
      id: string,
      credentialId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmUsersIdCredentialsCredentialIdMoveToFirstPost',
        'realm',
        realm
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists(
        'realmUsersIdCredentialsCredentialIdMoveToFirstPost',
        'id',
        id
      );
      // verify required parameter 'credentialId' is not null or undefined
      assertParamExists(
        'realmUsersIdCredentialsCredentialIdMoveToFirstPost',
        'credentialId',
        credentialId
      );
      const localVarPath =
        `/{realm}/users/{id}/credentials/{credentialId}/moveToFirst`
          .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
          .replace(`{${'id'}}`, encodeURIComponent(String(id)))
          .replace(
            `{${'credentialId'}}`,
            encodeURIComponent(String(credentialId))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update a credential label for a user
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {string} credentialId
     * @param {string} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdCredentialsCredentialIdUserLabelPut: async (
      realm: string,
      id: string,
      credentialId: string,
      body: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmUsersIdCredentialsCredentialIdUserLabelPut',
        'realm',
        realm
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists(
        'realmUsersIdCredentialsCredentialIdUserLabelPut',
        'id',
        id
      );
      // verify required parameter 'credentialId' is not null or undefined
      assertParamExists(
        'realmUsersIdCredentialsCredentialIdUserLabelPut',
        'credentialId',
        credentialId
      );
      // verify required parameter 'body' is not null or undefined
      assertParamExists(
        'realmUsersIdCredentialsCredentialIdUserLabelPut',
        'body',
        body
      );
      const localVarPath =
        `/{realm}/users/{id}/credentials/{credentialId}/userLabel`
          .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
          .replace(`{${'id'}}`, encodeURIComponent(String(id)))
          .replace(
            `{${'credentialId'}}`,
            encodeURIComponent(String(credentialId))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'text/plain';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdCredentialsGet: async (
      realm: string,
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmUsersIdCredentialsGet', 'realm', realm);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmUsersIdCredentialsGet', 'id', id);
      const localVarPath = `/{realm}/users/{id}/credentials`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete the user
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdDelete: async (
      realm: string,
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmUsersIdDelete', 'realm', realm);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmUsersIdDelete', 'id', id);
      const localVarPath = `/{realm}/users/{id}`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Disable all credentials for a user of a specific type
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdDisableCredentialTypesPut: async (
      realm: string,
      id: string,
      requestBody: Array<string>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmUsersIdDisableCredentialTypesPut',
        'realm',
        realm
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmUsersIdDisableCredentialTypesPut', 'id', id);
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists(
        'realmUsersIdDisableCredentialTypesPut',
        'requestBody',
        requestBody
      );
      const localVarPath = `/{realm}/users/{id}/disable-credential-types`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Send a update account email to the user   An email contains a link the user can click to perform a set of required actions.
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {Array<string>} requestBody required actions the user needs to complete
     * @param {string} [clientId] Client id
     * @param {number} [lifespan] Number of seconds after which the generated token expires
     * @param {string} [redirectUri] Redirect uri
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdExecuteActionsEmailPut: async (
      realm: string,
      id: string,
      requestBody: Array<string>,
      clientId?: string,
      lifespan?: number,
      redirectUri?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmUsersIdExecuteActionsEmailPut', 'realm', realm);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmUsersIdExecuteActionsEmailPut', 'id', id);
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists(
        'realmUsersIdExecuteActionsEmailPut',
        'requestBody',
        requestBody
      );
      const localVarPath = `/{realm}/users/{id}/execute-actions-email`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (clientId !== undefined) {
        localVarQueryParameter['client_id'] = clientId;
      }

      if (lifespan !== undefined) {
        localVarQueryParameter['lifespan'] = lifespan;
      }

      if (redirectUri !== undefined) {
        localVarQueryParameter['redirect_uri'] = redirectUri;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get social logins associated with the user
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdFederatedIdentityGet: async (
      realm: string,
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmUsersIdFederatedIdentityGet', 'realm', realm);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmUsersIdFederatedIdentityGet', 'id', id);
      const localVarPath = `/{realm}/users/{id}/federated-identity`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Remove a social login provider from user
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {string} provider Social login provider id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdFederatedIdentityProviderDelete: async (
      realm: string,
      id: string,
      provider: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmUsersIdFederatedIdentityProviderDelete',
        'realm',
        realm
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists(
        'realmUsersIdFederatedIdentityProviderDelete',
        'id',
        id
      );
      // verify required parameter 'provider' is not null or undefined
      assertParamExists(
        'realmUsersIdFederatedIdentityProviderDelete',
        'provider',
        provider
      );
      const localVarPath = `/{realm}/users/{id}/federated-identity/{provider}`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
        .replace(`{${'provider'}}`, encodeURIComponent(String(provider)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Add a social login provider to the user
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {string} provider Social login provider id
     * @param {FederatedIdentityRepresentation} federatedIdentityRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdFederatedIdentityProviderPost: async (
      realm: string,
      id: string,
      provider: string,
      federatedIdentityRepresentation: FederatedIdentityRepresentation,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmUsersIdFederatedIdentityProviderPost',
        'realm',
        realm
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmUsersIdFederatedIdentityProviderPost', 'id', id);
      // verify required parameter 'provider' is not null or undefined
      assertParamExists(
        'realmUsersIdFederatedIdentityProviderPost',
        'provider',
        provider
      );
      // verify required parameter 'federatedIdentityRepresentation' is not null or undefined
      assertParamExists(
        'realmUsersIdFederatedIdentityProviderPost',
        'federatedIdentityRepresentation',
        federatedIdentityRepresentation
      );
      const localVarPath = `/{realm}/users/{id}/federated-identity/{provider}`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
        .replace(`{${'provider'}}`, encodeURIComponent(String(provider)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        federatedIdentityRepresentation,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get representation of the user
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdGet: async (
      realm: string,
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmUsersIdGet', 'realm', realm);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmUsersIdGet', 'id', id);
      const localVarPath = `/{realm}/users/{id}`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {string} [search]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdGroupsCountGet: async (
      realm: string,
      id: string,
      search?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmUsersIdGroupsCountGet', 'realm', realm);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmUsersIdGroupsCountGet', 'id', id);
      const localVarPath = `/{realm}/users/{id}/groups/count`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (search !== undefined) {
        localVarQueryParameter['search'] = search;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {boolean} [briefRepresentation]
     * @param {number} [first]
     * @param {number} [max]
     * @param {string} [search]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdGroupsGet: async (
      realm: string,
      id: string,
      briefRepresentation?: boolean,
      first?: number,
      max?: number,
      search?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmUsersIdGroupsGet', 'realm', realm);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmUsersIdGroupsGet', 'id', id);
      const localVarPath = `/{realm}/users/{id}/groups`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (briefRepresentation !== undefined) {
        localVarQueryParameter['briefRepresentation'] = briefRepresentation;
      }

      if (first !== undefined) {
        localVarQueryParameter['first'] = first;
      }

      if (max !== undefined) {
        localVarQueryParameter['max'] = max;
      }

      if (search !== undefined) {
        localVarQueryParameter['search'] = search;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {string} groupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdGroupsGroupIdDelete: async (
      realm: string,
      id: string,
      groupId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmUsersIdGroupsGroupIdDelete', 'realm', realm);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmUsersIdGroupsGroupIdDelete', 'id', id);
      // verify required parameter 'groupId' is not null or undefined
      assertParamExists('realmUsersIdGroupsGroupIdDelete', 'groupId', groupId);
      const localVarPath = `/{realm}/users/{id}/groups/{groupId}`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
        .replace(`{${'groupId'}}`, encodeURIComponent(String(groupId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {string} groupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdGroupsGroupIdPut: async (
      realm: string,
      id: string,
      groupId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmUsersIdGroupsGroupIdPut', 'realm', realm);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmUsersIdGroupsGroupIdPut', 'id', id);
      // verify required parameter 'groupId' is not null or undefined
      assertParamExists('realmUsersIdGroupsGroupIdPut', 'groupId', groupId);
      const localVarPath = `/{realm}/users/{id}/groups/{groupId}`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
        .replace(`{${'groupId'}}`, encodeURIComponent(String(groupId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Impersonate the user
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdImpersonationPost: async (
      realm: string,
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmUsersIdImpersonationPost', 'realm', realm);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmUsersIdImpersonationPost', 'id', id);
      const localVarPath = `/{realm}/users/{id}/impersonation`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Remove all user sessions associated with the user   Also send notification to all clients that have an admin URL to invalidate the sessions for the particular user.
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdLogoutPost: async (
      realm: string,
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmUsersIdLogoutPost', 'realm', realm);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmUsersIdLogoutPost', 'id', id);
      const localVarPath = `/{realm}/users/{id}/logout`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get offline sessions associated with the user and client
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {string} clientUuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdOfflineSessionsClientUuidGet: async (
      realm: string,
      id: string,
      clientUuid: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmUsersIdOfflineSessionsClientUuidGet',
        'realm',
        realm
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmUsersIdOfflineSessionsClientUuidGet', 'id', id);
      // verify required parameter 'clientUuid' is not null or undefined
      assertParamExists(
        'realmUsersIdOfflineSessionsClientUuidGet',
        'clientUuid',
        clientUuid
      );
      const localVarPath = `/{realm}/users/{id}/offline-sessions/{clientUuid}`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
        .replace(`{${'clientUuid'}}`, encodeURIComponent(String(clientUuid)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update the user
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {UserRepresentation} userRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdPut: async (
      realm: string,
      id: string,
      userRepresentation: UserRepresentation,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmUsersIdPut', 'realm', realm);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmUsersIdPut', 'id', id);
      // verify required parameter 'userRepresentation' is not null or undefined
      assertParamExists(
        'realmUsersIdPut',
        'userRepresentation',
        userRepresentation
      );
      const localVarPath = `/{realm}/users/{id}`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userRepresentation,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Set up a new password for the user.
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {CredentialRepresentation} credentialRepresentation The representation must contain a rawPassword with the plain-text password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdResetPasswordPut: async (
      realm: string,
      id: string,
      credentialRepresentation: CredentialRepresentation,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmUsersIdResetPasswordPut', 'realm', realm);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmUsersIdResetPasswordPut', 'id', id);
      // verify required parameter 'credentialRepresentation' is not null or undefined
      assertParamExists(
        'realmUsersIdResetPasswordPut',
        'credentialRepresentation',
        credentialRepresentation
      );
      const localVarPath = `/{realm}/users/{id}/reset-password`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        credentialRepresentation,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Send an email-verification email to the user   An email contains a link the user can click to verify their email address.
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {string} [clientId] Client id
     * @param {string} [redirectUri] Redirect uri
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdSendVerifyEmailPut: async (
      realm: string,
      id: string,
      clientId?: string,
      redirectUri?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmUsersIdSendVerifyEmailPut', 'realm', realm);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmUsersIdSendVerifyEmailPut', 'id', id);
      const localVarPath = `/{realm}/users/{id}/send-verify-email`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (clientId !== undefined) {
        localVarQueryParameter['client_id'] = clientId;
      }

      if (redirectUri !== undefined) {
        localVarQueryParameter['redirect_uri'] = redirectUri;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get sessions associated with the user
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdSessionsGet: async (
      realm: string,
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmUsersIdSessionsGet', 'realm', realm);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmUsersIdSessionsGet', 'id', id);
      const localVarPath = `/{realm}/users/{id}/sessions`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create a new user   Username must be unique.
     * @param {string} realm realm name (not id!)
     * @param {UserRepresentation} userRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersPost: async (
      realm: string,
      userRepresentation: UserRepresentation,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmUsersPost', 'realm', realm);
      // verify required parameter 'userRepresentation' is not null or undefined
      assertParamExists(
        'realmUsersPost',
        'userRepresentation',
        userRepresentation
      );
      const localVarPath = `/{realm}/users`.replace(
        `{${'realm'}}`,
        encodeURIComponent(String(realm))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userRepresentation,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersProfileGet: async (
      realm: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmUsersProfileGet', 'realm', realm);
      const localVarPath = `/{realm}/users/profile`.replace(
        `{${'realm'}}`,
        encodeURIComponent(String(realm))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersProfilePut: async (
      realm: string,
      body: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmUsersProfilePut', 'realm', realm);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('realmUsersProfilePut', 'body', body);
      const localVarPath = `/{realm}/users/profile`.replace(
        `{${'realm'}}`,
        encodeURIComponent(String(realm))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Returns the number of users that match the given criteria.
     * @param {string} realm realm name (not id!)
     * @param {string} [email] email filter
     * @param {boolean} [emailVerified]
     * @param {boolean} [enabled] Boolean representing if user is enabled or not
     * @param {string} [firstName] first name filter
     * @param {string} [lastName] last name filter
     * @param {string} [search] arbitrary search string for all the fields below
     * @param {string} [username] username filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmUsersCountGet(
      realm: string,
      email?: string,
      emailVerified?: boolean,
      enabled?: boolean,
      firstName?: string,
      lastName?: string,
      search?: string,
      username?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmUsersCountGet(
          realm,
          email,
          emailVerified,
          enabled,
          firstName,
          lastName,
          search,
          username,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get users   Returns a stream of users, filtered according to query parameters.
     * @param {string} realm realm name (not id!)
     * @param {boolean} [briefRepresentation] Boolean which defines whether brief representations are returned (default: false)
     * @param {string} [email] A String contained in email, or the complete email, if param \&quot;exact\&quot; is true
     * @param {boolean} [emailVerified] whether the email has been verified
     * @param {boolean} [enabled] Boolean representing if user is enabled or not
     * @param {boolean} [exact] Boolean which defines whether the params \&quot;last\&quot;, \&quot;first\&quot;, \&quot;email\&quot; and \&quot;username\&quot; must match exactly
     * @param {number} [first] Pagination offset
     * @param {string} [firstName] A String contained in firstName, or the complete firstName, if param \&quot;exact\&quot; is true
     * @param {string} [idpAlias] The alias of an Identity Provider linked to the user
     * @param {string} [idpUserId] The userId at an Identity Provider linked to the user
     * @param {string} [lastName] A String contained in lastName, or the complete lastName, if param \&quot;exact\&quot; is true
     * @param {number} [max] Maximum results size (defaults to 100)
     * @param {string} [q] A query to search for custom attributes, in the format \&#39;key1:value2 key2:value2\&#39;
     * @param {string} [search] A String contained in username, first or last name, or email
     * @param {string} [username] A String contained in username, or the complete username, if param \&quot;exact\&quot; is true
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmUsersGet(
      realm: string,
      briefRepresentation?: boolean,
      email?: string,
      emailVerified?: boolean,
      enabled?: boolean,
      exact?: boolean,
      first?: number,
      firstName?: string,
      idpAlias?: string,
      idpUserId?: string,
      lastName?: string,
      max?: number,
      q?: string,
      search?: string,
      username?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<{ [key: string]: any }>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.realmUsersGet(
        realm,
        briefRepresentation,
        email,
        emailVerified,
        enabled,
        exact,
        first,
        firstName,
        idpAlias,
        idpUserId,
        lastName,
        max,
        q,
        search,
        username,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Return credential types, which are provided by the user storage where user is stored.
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmUsersIdConfiguredUserStorageCredentialTypesGet(
      realm: string,
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<{ [key: string]: any }>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmUsersIdConfiguredUserStorageCredentialTypesGet(
          realm,
          id,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Revoke consent and offline tokens for particular client from user
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {string} client Client id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmUsersIdConsentsClientDelete(
      realm: string,
      id: string,
      client: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmUsersIdConsentsClientDelete(
          realm,
          id,
          client,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get consents granted by the user
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmUsersIdConsentsGet(
      realm: string,
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<{ [key: string]: any }>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmUsersIdConsentsGet(
          realm,
          id,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Remove a credential for a user
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {string} credentialId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmUsersIdCredentialsCredentialIdDelete(
      realm: string,
      id: string,
      credentialId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmUsersIdCredentialsCredentialIdDelete(
          realm,
          id,
          credentialId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Move a credential to a position behind another credential
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {string} credentialId The credential to move
     * @param {string} newPreviousCredentialId The credential that will be the previous element in the list. If set to null, the moved credential will be the first element in the list.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmUsersIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPost(
      realm: string,
      id: string,
      credentialId: string,
      newPreviousCredentialId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmUsersIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPost(
          realm,
          id,
          credentialId,
          newPreviousCredentialId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Move a credential to a first position in the credentials list of the user
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {string} credentialId The credential to move
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmUsersIdCredentialsCredentialIdMoveToFirstPost(
      realm: string,
      id: string,
      credentialId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmUsersIdCredentialsCredentialIdMoveToFirstPost(
          realm,
          id,
          credentialId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Update a credential label for a user
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {string} credentialId
     * @param {string} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmUsersIdCredentialsCredentialIdUserLabelPut(
      realm: string,
      id: string,
      credentialId: string,
      body: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmUsersIdCredentialsCredentialIdUserLabelPut(
          realm,
          id,
          credentialId,
          body,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmUsersIdCredentialsGet(
      realm: string,
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<{ [key: string]: any }>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmUsersIdCredentialsGet(
          realm,
          id,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Delete the user
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmUsersIdDelete(
      realm: string,
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmUsersIdDelete(realm, id, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Disable all credentials for a user of a specific type
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmUsersIdDisableCredentialTypesPut(
      realm: string,
      id: string,
      requestBody: Array<string>,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmUsersIdDisableCredentialTypesPut(
          realm,
          id,
          requestBody,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Send a update account email to the user   An email contains a link the user can click to perform a set of required actions.
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {Array<string>} requestBody required actions the user needs to complete
     * @param {string} [clientId] Client id
     * @param {number} [lifespan] Number of seconds after which the generated token expires
     * @param {string} [redirectUri] Redirect uri
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmUsersIdExecuteActionsEmailPut(
      realm: string,
      id: string,
      requestBody: Array<string>,
      clientId?: string,
      lifespan?: number,
      redirectUri?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmUsersIdExecuteActionsEmailPut(
          realm,
          id,
          requestBody,
          clientId,
          lifespan,
          redirectUri,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get social logins associated with the user
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmUsersIdFederatedIdentityGet(
      realm: string,
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<{ [key: string]: any }>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmUsersIdFederatedIdentityGet(
          realm,
          id,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Remove a social login provider from user
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {string} provider Social login provider id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmUsersIdFederatedIdentityProviderDelete(
      realm: string,
      id: string,
      provider: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmUsersIdFederatedIdentityProviderDelete(
          realm,
          id,
          provider,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Add a social login provider to the user
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {string} provider Social login provider id
     * @param {FederatedIdentityRepresentation} federatedIdentityRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmUsersIdFederatedIdentityProviderPost(
      realm: string,
      id: string,
      provider: string,
      federatedIdentityRepresentation: FederatedIdentityRepresentation,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmUsersIdFederatedIdentityProviderPost(
          realm,
          id,
          provider,
          federatedIdentityRepresentation,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get representation of the user
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmUsersIdGet(
      realm: string,
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UserRepresentation>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.realmUsersIdGet(
        realm,
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {string} [search]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmUsersIdGroupsCountGet(
      realm: string,
      id: string,
      search?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: any }>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmUsersIdGroupsCountGet(
          realm,
          id,
          search,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {boolean} [briefRepresentation]
     * @param {number} [first]
     * @param {number} [max]
     * @param {string} [search]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmUsersIdGroupsGet(
      realm: string,
      id: string,
      briefRepresentation?: boolean,
      first?: number,
      max?: number,
      search?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<{ [key: string]: any }>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmUsersIdGroupsGet(
          realm,
          id,
          briefRepresentation,
          first,
          max,
          search,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {string} groupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmUsersIdGroupsGroupIdDelete(
      realm: string,
      id: string,
      groupId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmUsersIdGroupsGroupIdDelete(
          realm,
          id,
          groupId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {string} groupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmUsersIdGroupsGroupIdPut(
      realm: string,
      id: string,
      groupId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmUsersIdGroupsGroupIdPut(
          realm,
          id,
          groupId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Impersonate the user
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmUsersIdImpersonationPost(
      realm: string,
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: any }>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmUsersIdImpersonationPost(
          realm,
          id,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Remove all user sessions associated with the user   Also send notification to all clients that have an admin URL to invalidate the sessions for the particular user.
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmUsersIdLogoutPost(
      realm: string,
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmUsersIdLogoutPost(
          realm,
          id,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get offline sessions associated with the user and client
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {string} clientUuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmUsersIdOfflineSessionsClientUuidGet(
      realm: string,
      id: string,
      clientUuid: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<{ [key: string]: any }>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmUsersIdOfflineSessionsClientUuidGet(
          realm,
          id,
          clientUuid,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Update the user
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {UserRepresentation} userRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmUsersIdPut(
      realm: string,
      id: string,
      userRepresentation: UserRepresentation,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.realmUsersIdPut(
        realm,
        id,
        userRepresentation,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Set up a new password for the user.
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {CredentialRepresentation} credentialRepresentation The representation must contain a rawPassword with the plain-text password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmUsersIdResetPasswordPut(
      realm: string,
      id: string,
      credentialRepresentation: CredentialRepresentation,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmUsersIdResetPasswordPut(
          realm,
          id,
          credentialRepresentation,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Send an email-verification email to the user   An email contains a link the user can click to verify their email address.
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {string} [clientId] Client id
     * @param {string} [redirectUri] Redirect uri
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmUsersIdSendVerifyEmailPut(
      realm: string,
      id: string,
      clientId?: string,
      redirectUri?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmUsersIdSendVerifyEmailPut(
          realm,
          id,
          clientId,
          redirectUri,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get sessions associated with the user
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmUsersIdSessionsGet(
      realm: string,
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<{ [key: string]: any }>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmUsersIdSessionsGet(
          realm,
          id,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Create a new user   Username must be unique.
     * @param {string} realm realm name (not id!)
     * @param {UserRepresentation} userRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmUsersPost(
      realm: string,
      userRepresentation: UserRepresentation,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.realmUsersPost(
        realm,
        userRepresentation,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmUsersProfileGet(
      realm: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmUsersProfileGet(realm, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmUsersProfilePut(
      realm: string,
      body: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmUsersProfilePut(
          realm,
          body,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = UsersApiFp(configuration);
  return {
    /**
     *
     * @summary Returns the number of users that match the given criteria.
     * @param {string} realm realm name (not id!)
     * @param {string} [email] email filter
     * @param {boolean} [emailVerified]
     * @param {boolean} [enabled] Boolean representing if user is enabled or not
     * @param {string} [firstName] first name filter
     * @param {string} [lastName] last name filter
     * @param {string} [search] arbitrary search string for all the fields below
     * @param {string} [username] username filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersCountGet(
      realm: string,
      email?: string,
      emailVerified?: boolean,
      enabled?: boolean,
      firstName?: string,
      lastName?: string,
      search?: string,
      username?: string,
      options?: any
    ): AxiosPromise<number> {
      return localVarFp
        .realmUsersCountGet(
          realm,
          email,
          emailVerified,
          enabled,
          firstName,
          lastName,
          search,
          username,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get users   Returns a stream of users, filtered according to query parameters.
     * @param {string} realm realm name (not id!)
     * @param {boolean} [briefRepresentation] Boolean which defines whether brief representations are returned (default: false)
     * @param {string} [email] A String contained in email, or the complete email, if param \&quot;exact\&quot; is true
     * @param {boolean} [emailVerified] whether the email has been verified
     * @param {boolean} [enabled] Boolean representing if user is enabled or not
     * @param {boolean} [exact] Boolean which defines whether the params \&quot;last\&quot;, \&quot;first\&quot;, \&quot;email\&quot; and \&quot;username\&quot; must match exactly
     * @param {number} [first] Pagination offset
     * @param {string} [firstName] A String contained in firstName, or the complete firstName, if param \&quot;exact\&quot; is true
     * @param {string} [idpAlias] The alias of an Identity Provider linked to the user
     * @param {string} [idpUserId] The userId at an Identity Provider linked to the user
     * @param {string} [lastName] A String contained in lastName, or the complete lastName, if param \&quot;exact\&quot; is true
     * @param {number} [max] Maximum results size (defaults to 100)
     * @param {string} [q] A query to search for custom attributes, in the format \&#39;key1:value2 key2:value2\&#39;
     * @param {string} [search] A String contained in username, first or last name, or email
     * @param {string} [username] A String contained in username, or the complete username, if param \&quot;exact\&quot; is true
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersGet(
      realm: string,
      briefRepresentation?: boolean,
      email?: string,
      emailVerified?: boolean,
      enabled?: boolean,
      exact?: boolean,
      first?: number,
      firstName?: string,
      idpAlias?: string,
      idpUserId?: string,
      lastName?: string,
      max?: number,
      q?: string,
      search?: string,
      username?: string,
      options?: any
    ): AxiosPromise<Array<{ [key: string]: any }>> {
      return localVarFp
        .realmUsersGet(
          realm,
          briefRepresentation,
          email,
          emailVerified,
          enabled,
          exact,
          first,
          firstName,
          idpAlias,
          idpUserId,
          lastName,
          max,
          q,
          search,
          username,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Return credential types, which are provided by the user storage where user is stored.
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdConfiguredUserStorageCredentialTypesGet(
      realm: string,
      id: string,
      options?: any
    ): AxiosPromise<Array<{ [key: string]: any }>> {
      return localVarFp
        .realmUsersIdConfiguredUserStorageCredentialTypesGet(realm, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Revoke consent and offline tokens for particular client from user
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {string} client Client id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdConsentsClientDelete(
      realm: string,
      id: string,
      client: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmUsersIdConsentsClientDelete(realm, id, client, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get consents granted by the user
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdConsentsGet(
      realm: string,
      id: string,
      options?: any
    ): AxiosPromise<Array<{ [key: string]: any }>> {
      return localVarFp
        .realmUsersIdConsentsGet(realm, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Remove a credential for a user
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {string} credentialId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdCredentialsCredentialIdDelete(
      realm: string,
      id: string,
      credentialId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmUsersIdCredentialsCredentialIdDelete(
          realm,
          id,
          credentialId,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Move a credential to a position behind another credential
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {string} credentialId The credential to move
     * @param {string} newPreviousCredentialId The credential that will be the previous element in the list. If set to null, the moved credential will be the first element in the list.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPost(
      realm: string,
      id: string,
      credentialId: string,
      newPreviousCredentialId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmUsersIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPost(
          realm,
          id,
          credentialId,
          newPreviousCredentialId,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Move a credential to a first position in the credentials list of the user
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {string} credentialId The credential to move
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdCredentialsCredentialIdMoveToFirstPost(
      realm: string,
      id: string,
      credentialId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmUsersIdCredentialsCredentialIdMoveToFirstPost(
          realm,
          id,
          credentialId,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update a credential label for a user
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {string} credentialId
     * @param {string} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdCredentialsCredentialIdUserLabelPut(
      realm: string,
      id: string,
      credentialId: string,
      body: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmUsersIdCredentialsCredentialIdUserLabelPut(
          realm,
          id,
          credentialId,
          body,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdCredentialsGet(
      realm: string,
      id: string,
      options?: any
    ): AxiosPromise<Array<{ [key: string]: any }>> {
      return localVarFp
        .realmUsersIdCredentialsGet(realm, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete the user
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdDelete(
      realm: string,
      id: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmUsersIdDelete(realm, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Disable all credentials for a user of a specific type
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdDisableCredentialTypesPut(
      realm: string,
      id: string,
      requestBody: Array<string>,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmUsersIdDisableCredentialTypesPut(realm, id, requestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Send a update account email to the user   An email contains a link the user can click to perform a set of required actions.
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {Array<string>} requestBody required actions the user needs to complete
     * @param {string} [clientId] Client id
     * @param {number} [lifespan] Number of seconds after which the generated token expires
     * @param {string} [redirectUri] Redirect uri
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdExecuteActionsEmailPut(
      realm: string,
      id: string,
      requestBody: Array<string>,
      clientId?: string,
      lifespan?: number,
      redirectUri?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmUsersIdExecuteActionsEmailPut(
          realm,
          id,
          requestBody,
          clientId,
          lifespan,
          redirectUri,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get social logins associated with the user
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdFederatedIdentityGet(
      realm: string,
      id: string,
      options?: any
    ): AxiosPromise<Array<{ [key: string]: any }>> {
      return localVarFp
        .realmUsersIdFederatedIdentityGet(realm, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Remove a social login provider from user
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {string} provider Social login provider id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdFederatedIdentityProviderDelete(
      realm: string,
      id: string,
      provider: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmUsersIdFederatedIdentityProviderDelete(
          realm,
          id,
          provider,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Add a social login provider to the user
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {string} provider Social login provider id
     * @param {FederatedIdentityRepresentation} federatedIdentityRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdFederatedIdentityProviderPost(
      realm: string,
      id: string,
      provider: string,
      federatedIdentityRepresentation: FederatedIdentityRepresentation,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmUsersIdFederatedIdentityProviderPost(
          realm,
          id,
          provider,
          federatedIdentityRepresentation,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get representation of the user
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdGet(
      realm: string,
      id: string,
      options?: any
    ): AxiosPromise<UserRepresentation> {
      return localVarFp
        .realmUsersIdGet(realm, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {string} [search]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdGroupsCountGet(
      realm: string,
      id: string,
      search?: string,
      options?: any
    ): AxiosPromise<{ [key: string]: any }> {
      return localVarFp
        .realmUsersIdGroupsCountGet(realm, id, search, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {boolean} [briefRepresentation]
     * @param {number} [first]
     * @param {number} [max]
     * @param {string} [search]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdGroupsGet(
      realm: string,
      id: string,
      briefRepresentation?: boolean,
      first?: number,
      max?: number,
      search?: string,
      options?: any
    ): AxiosPromise<Array<{ [key: string]: any }>> {
      return localVarFp
        .realmUsersIdGroupsGet(
          realm,
          id,
          briefRepresentation,
          first,
          max,
          search,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {string} groupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdGroupsGroupIdDelete(
      realm: string,
      id: string,
      groupId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmUsersIdGroupsGroupIdDelete(realm, id, groupId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {string} groupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdGroupsGroupIdPut(
      realm: string,
      id: string,
      groupId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmUsersIdGroupsGroupIdPut(realm, id, groupId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Impersonate the user
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdImpersonationPost(
      realm: string,
      id: string,
      options?: any
    ): AxiosPromise<{ [key: string]: any }> {
      return localVarFp
        .realmUsersIdImpersonationPost(realm, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Remove all user sessions associated with the user   Also send notification to all clients that have an admin URL to invalidate the sessions for the particular user.
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdLogoutPost(
      realm: string,
      id: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmUsersIdLogoutPost(realm, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get offline sessions associated with the user and client
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {string} clientUuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdOfflineSessionsClientUuidGet(
      realm: string,
      id: string,
      clientUuid: string,
      options?: any
    ): AxiosPromise<Array<{ [key: string]: any }>> {
      return localVarFp
        .realmUsersIdOfflineSessionsClientUuidGet(
          realm,
          id,
          clientUuid,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update the user
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {UserRepresentation} userRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdPut(
      realm: string,
      id: string,
      userRepresentation: UserRepresentation,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmUsersIdPut(realm, id, userRepresentation, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Set up a new password for the user.
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {CredentialRepresentation} credentialRepresentation The representation must contain a rawPassword with the plain-text password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdResetPasswordPut(
      realm: string,
      id: string,
      credentialRepresentation: CredentialRepresentation,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmUsersIdResetPasswordPut(
          realm,
          id,
          credentialRepresentation,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Send an email-verification email to the user   An email contains a link the user can click to verify their email address.
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {string} [clientId] Client id
     * @param {string} [redirectUri] Redirect uri
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdSendVerifyEmailPut(
      realm: string,
      id: string,
      clientId?: string,
      redirectUri?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmUsersIdSendVerifyEmailPut(
          realm,
          id,
          clientId,
          redirectUri,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get sessions associated with the user
     * @param {string} realm realm name (not id!)
     * @param {string} id User id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersIdSessionsGet(
      realm: string,
      id: string,
      options?: any
    ): AxiosPromise<Array<{ [key: string]: any }>> {
      return localVarFp
        .realmUsersIdSessionsGet(realm, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create a new user   Username must be unique.
     * @param {string} realm realm name (not id!)
     * @param {UserRepresentation} userRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersPost(
      realm: string,
      userRepresentation: UserRepresentation,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmUsersPost(realm, userRepresentation, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersProfileGet(realm: string, options?: any): AxiosPromise<string> {
      return localVarFp
        .realmUsersProfileGet(realm, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersProfilePut(
      realm: string,
      body: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmUsersProfilePut(realm, body, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
  /**
   *
   * @summary Returns the number of users that match the given criteria.
   * @param {string} realm realm name (not id!)
   * @param {string} [email] email filter
   * @param {boolean} [emailVerified]
   * @param {boolean} [enabled] Boolean representing if user is enabled or not
   * @param {string} [firstName] first name filter
   * @param {string} [lastName] last name filter
   * @param {string} [search] arbitrary search string for all the fields below
   * @param {string} [username] username filter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public realmUsersCountGet(
    realm: string,
    email?: string,
    emailVerified?: boolean,
    enabled?: boolean,
    firstName?: string,
    lastName?: string,
    search?: string,
    username?: string,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .realmUsersCountGet(
        realm,
        email,
        emailVerified,
        enabled,
        firstName,
        lastName,
        search,
        username,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get users   Returns a stream of users, filtered according to query parameters.
   * @param {string} realm realm name (not id!)
   * @param {boolean} [briefRepresentation] Boolean which defines whether brief representations are returned (default: false)
   * @param {string} [email] A String contained in email, or the complete email, if param \&quot;exact\&quot; is true
   * @param {boolean} [emailVerified] whether the email has been verified
   * @param {boolean} [enabled] Boolean representing if user is enabled or not
   * @param {boolean} [exact] Boolean which defines whether the params \&quot;last\&quot;, \&quot;first\&quot;, \&quot;email\&quot; and \&quot;username\&quot; must match exactly
   * @param {number} [first] Pagination offset
   * @param {string} [firstName] A String contained in firstName, or the complete firstName, if param \&quot;exact\&quot; is true
   * @param {string} [idpAlias] The alias of an Identity Provider linked to the user
   * @param {string} [idpUserId] The userId at an Identity Provider linked to the user
   * @param {string} [lastName] A String contained in lastName, or the complete lastName, if param \&quot;exact\&quot; is true
   * @param {number} [max] Maximum results size (defaults to 100)
   * @param {string} [q] A query to search for custom attributes, in the format \&#39;key1:value2 key2:value2\&#39;
   * @param {string} [search] A String contained in username, first or last name, or email
   * @param {string} [username] A String contained in username, or the complete username, if param \&quot;exact\&quot; is true
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public realmUsersGet(
    realm: string,
    briefRepresentation?: boolean,
    email?: string,
    emailVerified?: boolean,
    enabled?: boolean,
    exact?: boolean,
    first?: number,
    firstName?: string,
    idpAlias?: string,
    idpUserId?: string,
    lastName?: string,
    max?: number,
    q?: string,
    search?: string,
    username?: string,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .realmUsersGet(
        realm,
        briefRepresentation,
        email,
        emailVerified,
        enabled,
        exact,
        first,
        firstName,
        idpAlias,
        idpUserId,
        lastName,
        max,
        q,
        search,
        username,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Return credential types, which are provided by the user storage where user is stored.
   * @param {string} realm realm name (not id!)
   * @param {string} id User id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public realmUsersIdConfiguredUserStorageCredentialTypesGet(
    realm: string,
    id: string,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .realmUsersIdConfiguredUserStorageCredentialTypesGet(realm, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Revoke consent and offline tokens for particular client from user
   * @param {string} realm realm name (not id!)
   * @param {string} id User id
   * @param {string} client Client id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public realmUsersIdConsentsClientDelete(
    realm: string,
    id: string,
    client: string,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .realmUsersIdConsentsClientDelete(realm, id, client, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get consents granted by the user
   * @param {string} realm realm name (not id!)
   * @param {string} id User id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public realmUsersIdConsentsGet(
    realm: string,
    id: string,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .realmUsersIdConsentsGet(realm, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Remove a credential for a user
   * @param {string} realm realm name (not id!)
   * @param {string} id User id
   * @param {string} credentialId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public realmUsersIdCredentialsCredentialIdDelete(
    realm: string,
    id: string,
    credentialId: string,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .realmUsersIdCredentialsCredentialIdDelete(
        realm,
        id,
        credentialId,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Move a credential to a position behind another credential
   * @param {string} realm realm name (not id!)
   * @param {string} id User id
   * @param {string} credentialId The credential to move
   * @param {string} newPreviousCredentialId The credential that will be the previous element in the list. If set to null, the moved credential will be the first element in the list.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public realmUsersIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPost(
    realm: string,
    id: string,
    credentialId: string,
    newPreviousCredentialId: string,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .realmUsersIdCredentialsCredentialIdMoveAfterNewPreviousCredentialIdPost(
        realm,
        id,
        credentialId,
        newPreviousCredentialId,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Move a credential to a first position in the credentials list of the user
   * @param {string} realm realm name (not id!)
   * @param {string} id User id
   * @param {string} credentialId The credential to move
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public realmUsersIdCredentialsCredentialIdMoveToFirstPost(
    realm: string,
    id: string,
    credentialId: string,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .realmUsersIdCredentialsCredentialIdMoveToFirstPost(
        realm,
        id,
        credentialId,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update a credential label for a user
   * @param {string} realm realm name (not id!)
   * @param {string} id User id
   * @param {string} credentialId
   * @param {string} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public realmUsersIdCredentialsCredentialIdUserLabelPut(
    realm: string,
    id: string,
    credentialId: string,
    body: string,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .realmUsersIdCredentialsCredentialIdUserLabelPut(
        realm,
        id,
        credentialId,
        body,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} realm realm name (not id!)
   * @param {string} id User id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public realmUsersIdCredentialsGet(
    realm: string,
    id: string,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .realmUsersIdCredentialsGet(realm, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete the user
   * @param {string} realm realm name (not id!)
   * @param {string} id User id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public realmUsersIdDelete(
    realm: string,
    id: string,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .realmUsersIdDelete(realm, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Disable all credentials for a user of a specific type
   * @param {string} realm realm name (not id!)
   * @param {string} id User id
   * @param {Array<string>} requestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public realmUsersIdDisableCredentialTypesPut(
    realm: string,
    id: string,
    requestBody: Array<string>,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .realmUsersIdDisableCredentialTypesPut(realm, id, requestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Send a update account email to the user   An email contains a link the user can click to perform a set of required actions.
   * @param {string} realm realm name (not id!)
   * @param {string} id User id
   * @param {Array<string>} requestBody required actions the user needs to complete
   * @param {string} [clientId] Client id
   * @param {number} [lifespan] Number of seconds after which the generated token expires
   * @param {string} [redirectUri] Redirect uri
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public realmUsersIdExecuteActionsEmailPut(
    realm: string,
    id: string,
    requestBody: Array<string>,
    clientId?: string,
    lifespan?: number,
    redirectUri?: string,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .realmUsersIdExecuteActionsEmailPut(
        realm,
        id,
        requestBody,
        clientId,
        lifespan,
        redirectUri,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get social logins associated with the user
   * @param {string} realm realm name (not id!)
   * @param {string} id User id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public realmUsersIdFederatedIdentityGet(
    realm: string,
    id: string,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .realmUsersIdFederatedIdentityGet(realm, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Remove a social login provider from user
   * @param {string} realm realm name (not id!)
   * @param {string} id User id
   * @param {string} provider Social login provider id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public realmUsersIdFederatedIdentityProviderDelete(
    realm: string,
    id: string,
    provider: string,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .realmUsersIdFederatedIdentityProviderDelete(realm, id, provider, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Add a social login provider to the user
   * @param {string} realm realm name (not id!)
   * @param {string} id User id
   * @param {string} provider Social login provider id
   * @param {FederatedIdentityRepresentation} federatedIdentityRepresentation
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public realmUsersIdFederatedIdentityProviderPost(
    realm: string,
    id: string,
    provider: string,
    federatedIdentityRepresentation: FederatedIdentityRepresentation,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .realmUsersIdFederatedIdentityProviderPost(
        realm,
        id,
        provider,
        federatedIdentityRepresentation,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get representation of the user
   * @param {string} realm realm name (not id!)
   * @param {string} id User id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public realmUsersIdGet(
    realm: string,
    id: string,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .realmUsersIdGet(realm, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} realm realm name (not id!)
   * @param {string} id User id
   * @param {string} [search]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public realmUsersIdGroupsCountGet(
    realm: string,
    id: string,
    search?: string,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .realmUsersIdGroupsCountGet(realm, id, search, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} realm realm name (not id!)
   * @param {string} id User id
   * @param {boolean} [briefRepresentation]
   * @param {number} [first]
   * @param {number} [max]
   * @param {string} [search]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public realmUsersIdGroupsGet(
    realm: string,
    id: string,
    briefRepresentation?: boolean,
    first?: number,
    max?: number,
    search?: string,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .realmUsersIdGroupsGet(
        realm,
        id,
        briefRepresentation,
        first,
        max,
        search,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} realm realm name (not id!)
   * @param {string} id User id
   * @param {string} groupId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public realmUsersIdGroupsGroupIdDelete(
    realm: string,
    id: string,
    groupId: string,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .realmUsersIdGroupsGroupIdDelete(realm, id, groupId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} realm realm name (not id!)
   * @param {string} id User id
   * @param {string} groupId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public realmUsersIdGroupsGroupIdPut(
    realm: string,
    id: string,
    groupId: string,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .realmUsersIdGroupsGroupIdPut(realm, id, groupId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Impersonate the user
   * @param {string} realm realm name (not id!)
   * @param {string} id User id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public realmUsersIdImpersonationPost(
    realm: string,
    id: string,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .realmUsersIdImpersonationPost(realm, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Remove all user sessions associated with the user   Also send notification to all clients that have an admin URL to invalidate the sessions for the particular user.
   * @param {string} realm realm name (not id!)
   * @param {string} id User id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public realmUsersIdLogoutPost(
    realm: string,
    id: string,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .realmUsersIdLogoutPost(realm, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get offline sessions associated with the user and client
   * @param {string} realm realm name (not id!)
   * @param {string} id User id
   * @param {string} clientUuid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public realmUsersIdOfflineSessionsClientUuidGet(
    realm: string,
    id: string,
    clientUuid: string,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .realmUsersIdOfflineSessionsClientUuidGet(realm, id, clientUuid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update the user
   * @param {string} realm realm name (not id!)
   * @param {string} id User id
   * @param {UserRepresentation} userRepresentation
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public realmUsersIdPut(
    realm: string,
    id: string,
    userRepresentation: UserRepresentation,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .realmUsersIdPut(realm, id, userRepresentation, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Set up a new password for the user.
   * @param {string} realm realm name (not id!)
   * @param {string} id User id
   * @param {CredentialRepresentation} credentialRepresentation The representation must contain a rawPassword with the plain-text password
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public realmUsersIdResetPasswordPut(
    realm: string,
    id: string,
    credentialRepresentation: CredentialRepresentation,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .realmUsersIdResetPasswordPut(
        realm,
        id,
        credentialRepresentation,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Send an email-verification email to the user   An email contains a link the user can click to verify their email address.
   * @param {string} realm realm name (not id!)
   * @param {string} id User id
   * @param {string} [clientId] Client id
   * @param {string} [redirectUri] Redirect uri
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public realmUsersIdSendVerifyEmailPut(
    realm: string,
    id: string,
    clientId?: string,
    redirectUri?: string,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .realmUsersIdSendVerifyEmailPut(realm, id, clientId, redirectUri, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get sessions associated with the user
   * @param {string} realm realm name (not id!)
   * @param {string} id User id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public realmUsersIdSessionsGet(
    realm: string,
    id: string,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .realmUsersIdSessionsGet(realm, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create a new user   Username must be unique.
   * @param {string} realm realm name (not id!)
   * @param {UserRepresentation} userRepresentation
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public realmUsersPost(
    realm: string,
    userRepresentation: UserRepresentation,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .realmUsersPost(realm, userRepresentation, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} realm realm name (not id!)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public realmUsersProfileGet(realm: string, options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .realmUsersProfileGet(realm, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} realm realm name (not id!)
   * @param {string} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public realmUsersProfilePut(
    realm: string,
    body: string,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .realmUsersProfilePut(realm, body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
