/* tslint:disable */
/* eslint-disable */
/**
 * Keycloak Admin REST API
 * This is a REST API reference for the Keycloak Admin REST API.
 *
 * The version of the OpenAPI document: 1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from '../common';
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from '../base';
// @ts-ignore
import { AccessToken } from '../model';
// @ts-ignore
import { ClientRepresentation } from '../model';
// @ts-ignore
import { CredentialRepresentation } from '../model';
// @ts-ignore
import { GlobalRequestResult } from '../model';
// @ts-ignore
import { IDToken } from '../model';
// @ts-ignore
import { ManagementPermissionReference } from '../model';
// @ts-ignore
import { UserRepresentation } from '../model';
/**
 * ClientsApi - axios parameter creator
 * @export
 */
export const ClientsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Get clients belonging to the realm.
     * @param {string} realm realm name (not id!)
     * @param {string} [clientId] filter by clientId
     * @param {number} [first] the first result
     * @param {number} [max] the max results to return
     * @param {string} [q]
     * @param {boolean} [search] whether this is a search query or a getClientById query
     * @param {boolean} [viewableOnly] filter clients that cannot be viewed in full by admin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsGet: async (
      realm: string,
      clientId?: string,
      first?: number,
      max?: number,
      q?: string,
      search?: boolean,
      viewableOnly?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmClientsGet', 'realm', realm);
      const localVarPath = `/{realm}/clients`.replace(
        `{${'realm'}}`,
        encodeURIComponent(String(realm))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (clientId !== undefined) {
        localVarQueryParameter['clientId'] = clientId;
      }

      if (first !== undefined) {
        localVarQueryParameter['first'] = first;
      }

      if (max !== undefined) {
        localVarQueryParameter['max'] = max;
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q;
      }

      if (search !== undefined) {
        localVarQueryParameter['search'] = search;
      }

      if (viewableOnly !== undefined) {
        localVarQueryParameter['viewableOnly'] = viewableOnly;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the client secret
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdClientSecretGet: async (
      realm: string,
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmClientsIdClientSecretGet', 'realm', realm);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmClientsIdClientSecretGet', 'id', id);
      const localVarPath = `/{realm}/clients/{id}/client-secret`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Generate a new secret for the client
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdClientSecretPost: async (
      realm: string,
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmClientsIdClientSecretPost', 'realm', realm);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmClientsIdClientSecretPost', 'id', id);
      const localVarPath = `/{realm}/clients/{id}/client-secret`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Invalidate the rotated secret for the client
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdClientSecretRotatedDelete: async (
      realm: string,
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmClientsIdClientSecretRotatedDelete',
        'realm',
        realm
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmClientsIdClientSecretRotatedDelete', 'id', id);
      const localVarPath = `/{realm}/clients/{id}/client-secret/rotated`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the rotated client secret
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdClientSecretRotatedGet: async (
      realm: string,
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmClientsIdClientSecretRotatedGet', 'realm', realm);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmClientsIdClientSecretRotatedGet', 'id', id);
      const localVarPath = `/{realm}/clients/{id}/client-secret/rotated`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} clientScopeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdDefaultClientScopesClientScopeIdDelete: async (
      realm: string,
      id: string,
      clientScopeId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmClientsIdDefaultClientScopesClientScopeIdDelete',
        'realm',
        realm
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists(
        'realmClientsIdDefaultClientScopesClientScopeIdDelete',
        'id',
        id
      );
      // verify required parameter 'clientScopeId' is not null or undefined
      assertParamExists(
        'realmClientsIdDefaultClientScopesClientScopeIdDelete',
        'clientScopeId',
        clientScopeId
      );
      const localVarPath =
        `/{realm}/clients/{id}/default-client-scopes/{clientScopeId}`
          .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
          .replace(`{${'id'}}`, encodeURIComponent(String(id)))
          .replace(
            `{${'clientScopeId'}}`,
            encodeURIComponent(String(clientScopeId))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} clientScopeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdDefaultClientScopesClientScopeIdPut: async (
      realm: string,
      id: string,
      clientScopeId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmClientsIdDefaultClientScopesClientScopeIdPut',
        'realm',
        realm
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists(
        'realmClientsIdDefaultClientScopesClientScopeIdPut',
        'id',
        id
      );
      // verify required parameter 'clientScopeId' is not null or undefined
      assertParamExists(
        'realmClientsIdDefaultClientScopesClientScopeIdPut',
        'clientScopeId',
        clientScopeId
      );
      const localVarPath =
        `/{realm}/clients/{id}/default-client-scopes/{clientScopeId}`
          .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
          .replace(`{${'id'}}`, encodeURIComponent(String(id)))
          .replace(
            `{${'clientScopeId'}}`,
            encodeURIComponent(String(clientScopeId))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get default client scopes.
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdDefaultClientScopesGet: async (
      realm: string,
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmClientsIdDefaultClientScopesGet', 'realm', realm);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmClientsIdDefaultClientScopesGet', 'id', id);
      const localVarPath = `/{realm}/clients/{id}/default-client-scopes`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete the client
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdDelete: async (
      realm: string,
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmClientsIdDelete', 'realm', realm);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmClientsIdDelete', 'id', id);
      const localVarPath = `/{realm}/clients/{id}`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create JSON with payload of example access token
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} [scope]
     * @param {string} [userId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdEvaluateScopesGenerateExampleAccessTokenGet: async (
      realm: string,
      id: string,
      scope?: string,
      userId?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmClientsIdEvaluateScopesGenerateExampleAccessTokenGet',
        'realm',
        realm
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists(
        'realmClientsIdEvaluateScopesGenerateExampleAccessTokenGet',
        'id',
        id
      );
      const localVarPath =
        `/{realm}/clients/{id}/evaluate-scopes/generate-example-access-token`
          .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
          .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (scope !== undefined) {
        localVarQueryParameter['scope'] = scope;
      }

      if (userId !== undefined) {
        localVarQueryParameter['userId'] = userId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create JSON with payload of example id token
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} [scope]
     * @param {string} [userId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdEvaluateScopesGenerateExampleIdTokenGet: async (
      realm: string,
      id: string,
      scope?: string,
      userId?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmClientsIdEvaluateScopesGenerateExampleIdTokenGet',
        'realm',
        realm
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists(
        'realmClientsIdEvaluateScopesGenerateExampleIdTokenGet',
        'id',
        id
      );
      const localVarPath =
        `/{realm}/clients/{id}/evaluate-scopes/generate-example-id-token`
          .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
          .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (scope !== undefined) {
        localVarQueryParameter['scope'] = scope;
      }

      if (userId !== undefined) {
        localVarQueryParameter['userId'] = userId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create JSON with payload of example user info
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} [scope]
     * @param {string} [userId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdEvaluateScopesGenerateExampleUserinfoGet: async (
      realm: string,
      id: string,
      scope?: string,
      userId?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmClientsIdEvaluateScopesGenerateExampleUserinfoGet',
        'realm',
        realm
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists(
        'realmClientsIdEvaluateScopesGenerateExampleUserinfoGet',
        'id',
        id
      );
      const localVarPath =
        `/{realm}/clients/{id}/evaluate-scopes/generate-example-userinfo`
          .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
          .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (scope !== undefined) {
        localVarQueryParameter['scope'] = scope;
      }

      if (userId !== undefined) {
        localVarQueryParameter['userId'] = userId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Return list of all protocol mappers, which will be used when generating tokens issued for particular client.
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} [scope]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdEvaluateScopesProtocolMappersGet: async (
      realm: string,
      id: string,
      scope?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmClientsIdEvaluateScopesProtocolMappersGet',
        'realm',
        realm
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists(
        'realmClientsIdEvaluateScopesProtocolMappersGet',
        'id',
        id
      );
      const localVarPath =
        `/{realm}/clients/{id}/evaluate-scopes/protocol-mappers`
          .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
          .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (scope !== undefined) {
        localVarQueryParameter['scope'] = scope;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get effective scope mapping of all roles of particular role container, which this client is defacto allowed to have in the accessToken issued for him.
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} roleContainerId either realm name OR client UUID
     * @param {string} [scope]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdEvaluateScopesScopeMappingsRoleContainerIdGrantedGet: async (
      realm: string,
      id: string,
      roleContainerId: string,
      scope?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmClientsIdEvaluateScopesScopeMappingsRoleContainerIdGrantedGet',
        'realm',
        realm
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists(
        'realmClientsIdEvaluateScopesScopeMappingsRoleContainerIdGrantedGet',
        'id',
        id
      );
      // verify required parameter 'roleContainerId' is not null or undefined
      assertParamExists(
        'realmClientsIdEvaluateScopesScopeMappingsRoleContainerIdGrantedGet',
        'roleContainerId',
        roleContainerId
      );
      const localVarPath =
        `/{realm}/clients/{id}/evaluate-scopes/scope-mappings/{roleContainerId}/granted`
          .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
          .replace(`{${'id'}}`, encodeURIComponent(String(id)))
          .replace(
            `{${'roleContainerId'}}`,
            encodeURIComponent(String(roleContainerId))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (scope !== undefined) {
        localVarQueryParameter['scope'] = scope;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get roles, which this client doesn’t have scope for and can’t have them in the accessToken issued for him.
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} roleContainerId either realm name OR client UUID
     * @param {string} [scope]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGet:
      async (
        realm: string,
        id: string,
        roleContainerId: string,
        scope?: string,
        options: AxiosRequestConfig = {}
      ): Promise<RequestArgs> => {
        // verify required parameter 'realm' is not null or undefined
        assertParamExists(
          'realmClientsIdEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGet',
          'realm',
          realm
        );
        // verify required parameter 'id' is not null or undefined
        assertParamExists(
          'realmClientsIdEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGet',
          'id',
          id
        );
        // verify required parameter 'roleContainerId' is not null or undefined
        assertParamExists(
          'realmClientsIdEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGet',
          'roleContainerId',
          roleContainerId
        );
        const localVarPath =
          `/{realm}/clients/{id}/evaluate-scopes/scope-mappings/{roleContainerId}/not-granted`
            .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
            .replace(`{${'id'}}`, encodeURIComponent(String(id)))
            .replace(
              `{${'roleContainerId'}}`,
              encodeURIComponent(String(roleContainerId))
            );
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = {
          method: 'GET',
          ...baseOptions,
          ...options,
        };
        const localVarHeaderParameter = {} as any;
        const localVarQueryParameter = {} as any;

        // authentication access_token required
        // http bearer authentication required
        await setBearerAuthToObject(localVarHeaderParameter, configuration);

        if (scope !== undefined) {
          localVarQueryParameter['scope'] = scope;
        }

        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = {
          ...localVarHeaderParameter,
          ...headersFromBaseOptions,
          ...options.headers,
        };

        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions,
        };
      },
    /**
     *
     * @summary Get representation of the client
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdGet: async (
      realm: string,
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmClientsIdGet', 'realm', realm);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmClientsIdGet', 'id', id);
      const localVarPath = `/{realm}/clients/{id}`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} providerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdInstallationProvidersProviderIdGet: async (
      realm: string,
      id: string,
      providerId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmClientsIdInstallationProvidersProviderIdGet',
        'realm',
        realm
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists(
        'realmClientsIdInstallationProvidersProviderIdGet',
        'id',
        id
      );
      // verify required parameter 'providerId' is not null or undefined
      assertParamExists(
        'realmClientsIdInstallationProvidersProviderIdGet',
        'providerId',
        providerId
      );
      const localVarPath =
        `/{realm}/clients/{id}/installation/providers/{providerId}`
          .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
          .replace(`{${'id'}}`, encodeURIComponent(String(id)))
          .replace(`{${'providerId'}}`, encodeURIComponent(String(providerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Return object stating whether client Authorization permissions have been initialized or not and a reference
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdManagementPermissionsGet: async (
      realm: string,
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmClientsIdManagementPermissionsGet',
        'realm',
        realm
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmClientsIdManagementPermissionsGet', 'id', id);
      const localVarPath = `/{realm}/clients/{id}/management/permissions`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Return object stating whether client Authorization permissions have been initialized or not and a reference
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {ManagementPermissionReference} managementPermissionReference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdManagementPermissionsPut: async (
      realm: string,
      id: string,
      managementPermissionReference: ManagementPermissionReference,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmClientsIdManagementPermissionsPut',
        'realm',
        realm
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmClientsIdManagementPermissionsPut', 'id', id);
      // verify required parameter 'managementPermissionReference' is not null or undefined
      assertParamExists(
        'realmClientsIdManagementPermissionsPut',
        'managementPermissionReference',
        managementPermissionReference
      );
      const localVarPath = `/{realm}/clients/{id}/management/permissions`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        managementPermissionReference,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Unregister a cluster node from the client
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} node
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdNodesNodeDelete: async (
      realm: string,
      id: string,
      node: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmClientsIdNodesNodeDelete', 'realm', realm);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmClientsIdNodesNodeDelete', 'id', id);
      // verify required parameter 'node' is not null or undefined
      assertParamExists('realmClientsIdNodesNodeDelete', 'node', node);
      const localVarPath = `/{realm}/clients/{id}/nodes/{node}`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
        .replace(`{${'node'}}`, encodeURIComponent(String(node)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Register a cluster node with the client   Manually register cluster node to this client - usually it’s not needed to call this directly as adapter should handle  by sending registration request to Keycloak
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {{ [key: string]: any; }} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdNodesPost: async (
      realm: string,
      id: string,
      requestBody: { [key: string]: any },
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmClientsIdNodesPost', 'realm', realm);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmClientsIdNodesPost', 'id', id);
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists('realmClientsIdNodesPost', 'requestBody', requestBody);
      const localVarPath = `/{realm}/clients/{id}/nodes`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get application offline session count   Returns a number of offline user sessions associated with this client   {      \"count\": number  }
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdOfflineSessionCountGet: async (
      realm: string,
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmClientsIdOfflineSessionCountGet', 'realm', realm);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmClientsIdOfflineSessionCountGet', 'id', id);
      const localVarPath = `/{realm}/clients/{id}/offline-session-count`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get offline sessions for client   Returns a list of offline user sessions associated with this client
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {number} [first] Paging offset
     * @param {number} [max] Maximum results size (defaults to 100)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdOfflineSessionsGet: async (
      realm: string,
      id: string,
      first?: number,
      max?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmClientsIdOfflineSessionsGet', 'realm', realm);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmClientsIdOfflineSessionsGet', 'id', id);
      const localVarPath = `/{realm}/clients/{id}/offline-sessions`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (first !== undefined) {
        localVarQueryParameter['first'] = first;
      }

      if (max !== undefined) {
        localVarQueryParameter['max'] = max;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} clientScopeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdOptionalClientScopesClientScopeIdDelete: async (
      realm: string,
      id: string,
      clientScopeId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmClientsIdOptionalClientScopesClientScopeIdDelete',
        'realm',
        realm
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists(
        'realmClientsIdOptionalClientScopesClientScopeIdDelete',
        'id',
        id
      );
      // verify required parameter 'clientScopeId' is not null or undefined
      assertParamExists(
        'realmClientsIdOptionalClientScopesClientScopeIdDelete',
        'clientScopeId',
        clientScopeId
      );
      const localVarPath =
        `/{realm}/clients/{id}/optional-client-scopes/{clientScopeId}`
          .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
          .replace(`{${'id'}}`, encodeURIComponent(String(id)))
          .replace(
            `{${'clientScopeId'}}`,
            encodeURIComponent(String(clientScopeId))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} clientScopeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdOptionalClientScopesClientScopeIdPut: async (
      realm: string,
      id: string,
      clientScopeId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmClientsIdOptionalClientScopesClientScopeIdPut',
        'realm',
        realm
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists(
        'realmClientsIdOptionalClientScopesClientScopeIdPut',
        'id',
        id
      );
      // verify required parameter 'clientScopeId' is not null or undefined
      assertParamExists(
        'realmClientsIdOptionalClientScopesClientScopeIdPut',
        'clientScopeId',
        clientScopeId
      );
      const localVarPath =
        `/{realm}/clients/{id}/optional-client-scopes/{clientScopeId}`
          .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
          .replace(`{${'id'}}`, encodeURIComponent(String(id)))
          .replace(
            `{${'clientScopeId'}}`,
            encodeURIComponent(String(clientScopeId))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get optional client scopes.
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdOptionalClientScopesGet: async (
      realm: string,
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmClientsIdOptionalClientScopesGet',
        'realm',
        realm
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmClientsIdOptionalClientScopesGet', 'id', id);
      const localVarPath = `/{realm}/clients/{id}/optional-client-scopes`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Push the client’s revocation policy to its admin URL   If the client has an admin URL, push revocation policy to it.
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdPushRevocationPost: async (
      realm: string,
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmClientsIdPushRevocationPost', 'realm', realm);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmClientsIdPushRevocationPost', 'id', id);
      const localVarPath = `/{realm}/clients/{id}/push-revocation`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update the client
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {ClientRepresentation} clientRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdPut: async (
      realm: string,
      id: string,
      clientRepresentation: ClientRepresentation,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmClientsIdPut', 'realm', realm);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmClientsIdPut', 'id', id);
      // verify required parameter 'clientRepresentation' is not null or undefined
      assertParamExists(
        'realmClientsIdPut',
        'clientRepresentation',
        clientRepresentation
      );
      const localVarPath = `/{realm}/clients/{id}`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        clientRepresentation,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Generate a new registration access token for the client
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdRegistrationAccessTokenPost: async (
      realm: string,
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmClientsIdRegistrationAccessTokenPost',
        'realm',
        realm
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmClientsIdRegistrationAccessTokenPost', 'id', id);
      const localVarPath = `/{realm}/clients/{id}/registration-access-token`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a user dedicated to the service account
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdServiceAccountUserGet: async (
      realm: string,
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmClientsIdServiceAccountUserGet', 'realm', realm);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmClientsIdServiceAccountUserGet', 'id', id);
      const localVarPath = `/{realm}/clients/{id}/service-account-user`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get application session count   Returns a number of user sessions associated with this client   {      \"count\": number  }
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdSessionCountGet: async (
      realm: string,
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmClientsIdSessionCountGet', 'realm', realm);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmClientsIdSessionCountGet', 'id', id);
      const localVarPath = `/{realm}/clients/{id}/session-count`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Test if registered cluster nodes are available   Tests availability by sending \'ping\' request to all cluster nodes.
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdTestNodesAvailableGet: async (
      realm: string,
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmClientsIdTestNodesAvailableGet', 'realm', realm);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmClientsIdTestNodesAvailableGet', 'id', id);
      const localVarPath = `/{realm}/clients/{id}/test-nodes-available`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get user sessions for client   Returns a list of user sessions associated with this client
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {number} [first] Paging offset
     * @param {number} [max] Maximum results size (defaults to 100)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdUserSessionsGet: async (
      realm: string,
      id: string,
      first?: number,
      max?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmClientsIdUserSessionsGet', 'realm', realm);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmClientsIdUserSessionsGet', 'id', id);
      const localVarPath = `/{realm}/clients/{id}/user-sessions`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (first !== undefined) {
        localVarQueryParameter['first'] = first;
      }

      if (max !== undefined) {
        localVarQueryParameter['max'] = max;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create a new client   Client’s client_id must be unique!
     * @param {string} realm realm name (not id!)
     * @param {ClientRepresentation} clientRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsPost: async (
      realm: string,
      clientRepresentation: ClientRepresentation,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmClientsPost', 'realm', realm);
      // verify required parameter 'clientRepresentation' is not null or undefined
      assertParamExists(
        'realmClientsPost',
        'clientRepresentation',
        clientRepresentation
      );
      const localVarPath = `/{realm}/clients`.replace(
        `{${'realm'}}`,
        encodeURIComponent(String(realm))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        clientRepresentation,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ClientsApi - functional programming interface
 * @export
 */
export const ClientsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ClientsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Get clients belonging to the realm.
     * @param {string} realm realm name (not id!)
     * @param {string} [clientId] filter by clientId
     * @param {number} [first] the first result
     * @param {number} [max] the max results to return
     * @param {string} [q]
     * @param {boolean} [search] whether this is a search query or a getClientById query
     * @param {boolean} [viewableOnly] filter clients that cannot be viewed in full by admin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientsGet(
      realm: string,
      clientId?: string,
      first?: number,
      max?: number,
      q?: string,
      search?: boolean,
      viewableOnly?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<{ [key: string]: any }>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.realmClientsGet(
        realm,
        clientId,
        first,
        max,
        q,
        search,
        viewableOnly,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get the client secret
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientsIdClientSecretGet(
      realm: string,
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CredentialRepresentation>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientsIdClientSecretGet(
          realm,
          id,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Generate a new secret for the client
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientsIdClientSecretPost(
      realm: string,
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CredentialRepresentation>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientsIdClientSecretPost(
          realm,
          id,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Invalidate the rotated secret for the client
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientsIdClientSecretRotatedDelete(
      realm: string,
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientsIdClientSecretRotatedDelete(
          realm,
          id,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get the rotated client secret
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientsIdClientSecretRotatedGet(
      realm: string,
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CredentialRepresentation>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientsIdClientSecretRotatedGet(
          realm,
          id,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} clientScopeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientsIdDefaultClientScopesClientScopeIdDelete(
      realm: string,
      id: string,
      clientScopeId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientsIdDefaultClientScopesClientScopeIdDelete(
          realm,
          id,
          clientScopeId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} clientScopeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientsIdDefaultClientScopesClientScopeIdPut(
      realm: string,
      id: string,
      clientScopeId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientsIdDefaultClientScopesClientScopeIdPut(
          realm,
          id,
          clientScopeId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get default client scopes.
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientsIdDefaultClientScopesGet(
      realm: string,
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<{ [key: string]: any }>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientsIdDefaultClientScopesGet(
          realm,
          id,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Delete the client
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientsIdDelete(
      realm: string,
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientsIdDelete(
          realm,
          id,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Create JSON with payload of example access token
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} [scope]
     * @param {string} [userId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientsIdEvaluateScopesGenerateExampleAccessTokenGet(
      realm: string,
      id: string,
      scope?: string,
      userId?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessToken>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientsIdEvaluateScopesGenerateExampleAccessTokenGet(
          realm,
          id,
          scope,
          userId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Create JSON with payload of example id token
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} [scope]
     * @param {string} [userId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientsIdEvaluateScopesGenerateExampleIdTokenGet(
      realm: string,
      id: string,
      scope?: string,
      userId?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<IDToken>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientsIdEvaluateScopesGenerateExampleIdTokenGet(
          realm,
          id,
          scope,
          userId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Create JSON with payload of example user info
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} [scope]
     * @param {string} [userId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientsIdEvaluateScopesGenerateExampleUserinfoGet(
      realm: string,
      id: string,
      scope?: string,
      userId?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: any }>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientsIdEvaluateScopesGenerateExampleUserinfoGet(
          realm,
          id,
          scope,
          userId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Return list of all protocol mappers, which will be used when generating tokens issued for particular client.
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} [scope]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientsIdEvaluateScopesProtocolMappersGet(
      realm: string,
      id: string,
      scope?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<{ [key: string]: any }>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientsIdEvaluateScopesProtocolMappersGet(
          realm,
          id,
          scope,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get effective scope mapping of all roles of particular role container, which this client is defacto allowed to have in the accessToken issued for him.
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} roleContainerId either realm name OR client UUID
     * @param {string} [scope]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientsIdEvaluateScopesScopeMappingsRoleContainerIdGrantedGet(
      realm: string,
      id: string,
      roleContainerId: string,
      scope?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<{ [key: string]: any }>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientsIdEvaluateScopesScopeMappingsRoleContainerIdGrantedGet(
          realm,
          id,
          roleContainerId,
          scope,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get roles, which this client doesn’t have scope for and can’t have them in the accessToken issued for him.
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} roleContainerId either realm name OR client UUID
     * @param {string} [scope]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientsIdEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGet(
      realm: string,
      id: string,
      roleContainerId: string,
      scope?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<{ [key: string]: any }>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientsIdEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGet(
          realm,
          id,
          roleContainerId,
          scope,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get representation of the client
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientsIdGet(
      realm: string,
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ClientRepresentation>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientsIdGet(realm, id, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} providerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientsIdInstallationProvidersProviderIdGet(
      realm: string,
      id: string,
      providerId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientsIdInstallationProvidersProviderIdGet(
          realm,
          id,
          providerId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Return object stating whether client Authorization permissions have been initialized or not and a reference
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientsIdManagementPermissionsGet(
      realm: string,
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ManagementPermissionReference>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientsIdManagementPermissionsGet(
          realm,
          id,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Return object stating whether client Authorization permissions have been initialized or not and a reference
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {ManagementPermissionReference} managementPermissionReference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientsIdManagementPermissionsPut(
      realm: string,
      id: string,
      managementPermissionReference: ManagementPermissionReference,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ManagementPermissionReference>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientsIdManagementPermissionsPut(
          realm,
          id,
          managementPermissionReference,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Unregister a cluster node from the client
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} node
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientsIdNodesNodeDelete(
      realm: string,
      id: string,
      node: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientsIdNodesNodeDelete(
          realm,
          id,
          node,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Register a cluster node with the client   Manually register cluster node to this client - usually it’s not needed to call this directly as adapter should handle  by sending registration request to Keycloak
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {{ [key: string]: any; }} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientsIdNodesPost(
      realm: string,
      id: string,
      requestBody: { [key: string]: any },
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientsIdNodesPost(
          realm,
          id,
          requestBody,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get application offline session count   Returns a number of offline user sessions associated with this client   {      \"count\": number  }
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientsIdOfflineSessionCountGet(
      realm: string,
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: any }>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientsIdOfflineSessionCountGet(
          realm,
          id,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get offline sessions for client   Returns a list of offline user sessions associated with this client
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {number} [first] Paging offset
     * @param {number} [max] Maximum results size (defaults to 100)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientsIdOfflineSessionsGet(
      realm: string,
      id: string,
      first?: number,
      max?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<{ [key: string]: any }>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientsIdOfflineSessionsGet(
          realm,
          id,
          first,
          max,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} clientScopeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientsIdOptionalClientScopesClientScopeIdDelete(
      realm: string,
      id: string,
      clientScopeId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientsIdOptionalClientScopesClientScopeIdDelete(
          realm,
          id,
          clientScopeId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} clientScopeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientsIdOptionalClientScopesClientScopeIdPut(
      realm: string,
      id: string,
      clientScopeId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientsIdOptionalClientScopesClientScopeIdPut(
          realm,
          id,
          clientScopeId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get optional client scopes.
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientsIdOptionalClientScopesGet(
      realm: string,
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<{ [key: string]: any }>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientsIdOptionalClientScopesGet(
          realm,
          id,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Push the client’s revocation policy to its admin URL   If the client has an admin URL, push revocation policy to it.
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientsIdPushRevocationPost(
      realm: string,
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GlobalRequestResult>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientsIdPushRevocationPost(
          realm,
          id,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Update the client
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {ClientRepresentation} clientRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientsIdPut(
      realm: string,
      id: string,
      clientRepresentation: ClientRepresentation,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientsIdPut(
          realm,
          id,
          clientRepresentation,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Generate a new registration access token for the client
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientsIdRegistrationAccessTokenPost(
      realm: string,
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ClientRepresentation>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientsIdRegistrationAccessTokenPost(
          realm,
          id,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get a user dedicated to the service account
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientsIdServiceAccountUserGet(
      realm: string,
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UserRepresentation>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientsIdServiceAccountUserGet(
          realm,
          id,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get application session count   Returns a number of user sessions associated with this client   {      \"count\": number  }
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientsIdSessionCountGet(
      realm: string,
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: any }>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientsIdSessionCountGet(
          realm,
          id,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Test if registered cluster nodes are available   Tests availability by sending \'ping\' request to all cluster nodes.
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientsIdTestNodesAvailableGet(
      realm: string,
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GlobalRequestResult>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientsIdTestNodesAvailableGet(
          realm,
          id,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get user sessions for client   Returns a list of user sessions associated with this client
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {number} [first] Paging offset
     * @param {number} [max] Maximum results size (defaults to 100)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientsIdUserSessionsGet(
      realm: string,
      id: string,
      first?: number,
      max?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<{ [key: string]: any }>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientsIdUserSessionsGet(
          realm,
          id,
          first,
          max,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Create a new client   Client’s client_id must be unique!
     * @param {string} realm realm name (not id!)
     * @param {ClientRepresentation} clientRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientsPost(
      realm: string,
      clientRepresentation: ClientRepresentation,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientsPost(
          realm,
          clientRepresentation,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * ClientsApi - factory interface
 * @export
 */
export const ClientsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ClientsApiFp(configuration);
  return {
    /**
     *
     * @summary Get clients belonging to the realm.
     * @param {string} realm realm name (not id!)
     * @param {string} [clientId] filter by clientId
     * @param {number} [first] the first result
     * @param {number} [max] the max results to return
     * @param {string} [q]
     * @param {boolean} [search] whether this is a search query or a getClientById query
     * @param {boolean} [viewableOnly] filter clients that cannot be viewed in full by admin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsGet(
      realm: string,
      clientId?: string,
      first?: number,
      max?: number,
      q?: string,
      search?: boolean,
      viewableOnly?: boolean,
      options?: any
    ): AxiosPromise<Array<{ [key: string]: any }>> {
      return localVarFp
        .realmClientsGet(
          realm,
          clientId,
          first,
          max,
          q,
          search,
          viewableOnly,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get the client secret
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdClientSecretGet(
      realm: string,
      id: string,
      options?: any
    ): AxiosPromise<CredentialRepresentation> {
      return localVarFp
        .realmClientsIdClientSecretGet(realm, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Generate a new secret for the client
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdClientSecretPost(
      realm: string,
      id: string,
      options?: any
    ): AxiosPromise<CredentialRepresentation> {
      return localVarFp
        .realmClientsIdClientSecretPost(realm, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Invalidate the rotated secret for the client
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdClientSecretRotatedDelete(
      realm: string,
      id: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmClientsIdClientSecretRotatedDelete(realm, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get the rotated client secret
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdClientSecretRotatedGet(
      realm: string,
      id: string,
      options?: any
    ): AxiosPromise<CredentialRepresentation> {
      return localVarFp
        .realmClientsIdClientSecretRotatedGet(realm, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} clientScopeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdDefaultClientScopesClientScopeIdDelete(
      realm: string,
      id: string,
      clientScopeId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmClientsIdDefaultClientScopesClientScopeIdDelete(
          realm,
          id,
          clientScopeId,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} clientScopeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdDefaultClientScopesClientScopeIdPut(
      realm: string,
      id: string,
      clientScopeId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmClientsIdDefaultClientScopesClientScopeIdPut(
          realm,
          id,
          clientScopeId,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get default client scopes.
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdDefaultClientScopesGet(
      realm: string,
      id: string,
      options?: any
    ): AxiosPromise<Array<{ [key: string]: any }>> {
      return localVarFp
        .realmClientsIdDefaultClientScopesGet(realm, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete the client
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdDelete(
      realm: string,
      id: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmClientsIdDelete(realm, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create JSON with payload of example access token
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} [scope]
     * @param {string} [userId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdEvaluateScopesGenerateExampleAccessTokenGet(
      realm: string,
      id: string,
      scope?: string,
      userId?: string,
      options?: any
    ): AxiosPromise<AccessToken> {
      return localVarFp
        .realmClientsIdEvaluateScopesGenerateExampleAccessTokenGet(
          realm,
          id,
          scope,
          userId,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create JSON with payload of example id token
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} [scope]
     * @param {string} [userId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdEvaluateScopesGenerateExampleIdTokenGet(
      realm: string,
      id: string,
      scope?: string,
      userId?: string,
      options?: any
    ): AxiosPromise<IDToken> {
      return localVarFp
        .realmClientsIdEvaluateScopesGenerateExampleIdTokenGet(
          realm,
          id,
          scope,
          userId,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create JSON with payload of example user info
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} [scope]
     * @param {string} [userId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdEvaluateScopesGenerateExampleUserinfoGet(
      realm: string,
      id: string,
      scope?: string,
      userId?: string,
      options?: any
    ): AxiosPromise<{ [key: string]: any }> {
      return localVarFp
        .realmClientsIdEvaluateScopesGenerateExampleUserinfoGet(
          realm,
          id,
          scope,
          userId,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Return list of all protocol mappers, which will be used when generating tokens issued for particular client.
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} [scope]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdEvaluateScopesProtocolMappersGet(
      realm: string,
      id: string,
      scope?: string,
      options?: any
    ): AxiosPromise<Array<{ [key: string]: any }>> {
      return localVarFp
        .realmClientsIdEvaluateScopesProtocolMappersGet(
          realm,
          id,
          scope,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get effective scope mapping of all roles of particular role container, which this client is defacto allowed to have in the accessToken issued for him.
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} roleContainerId either realm name OR client UUID
     * @param {string} [scope]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdEvaluateScopesScopeMappingsRoleContainerIdGrantedGet(
      realm: string,
      id: string,
      roleContainerId: string,
      scope?: string,
      options?: any
    ): AxiosPromise<Array<{ [key: string]: any }>> {
      return localVarFp
        .realmClientsIdEvaluateScopesScopeMappingsRoleContainerIdGrantedGet(
          realm,
          id,
          roleContainerId,
          scope,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get roles, which this client doesn’t have scope for and can’t have them in the accessToken issued for him.
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} roleContainerId either realm name OR client UUID
     * @param {string} [scope]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGet(
      realm: string,
      id: string,
      roleContainerId: string,
      scope?: string,
      options?: any
    ): AxiosPromise<Array<{ [key: string]: any }>> {
      return localVarFp
        .realmClientsIdEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGet(
          realm,
          id,
          roleContainerId,
          scope,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get representation of the client
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdGet(
      realm: string,
      id: string,
      options?: any
    ): AxiosPromise<ClientRepresentation> {
      return localVarFp
        .realmClientsIdGet(realm, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} providerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdInstallationProvidersProviderIdGet(
      realm: string,
      id: string,
      providerId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmClientsIdInstallationProvidersProviderIdGet(
          realm,
          id,
          providerId,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Return object stating whether client Authorization permissions have been initialized or not and a reference
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdManagementPermissionsGet(
      realm: string,
      id: string,
      options?: any
    ): AxiosPromise<ManagementPermissionReference> {
      return localVarFp
        .realmClientsIdManagementPermissionsGet(realm, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Return object stating whether client Authorization permissions have been initialized or not and a reference
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {ManagementPermissionReference} managementPermissionReference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdManagementPermissionsPut(
      realm: string,
      id: string,
      managementPermissionReference: ManagementPermissionReference,
      options?: any
    ): AxiosPromise<ManagementPermissionReference> {
      return localVarFp
        .realmClientsIdManagementPermissionsPut(
          realm,
          id,
          managementPermissionReference,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Unregister a cluster node from the client
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} node
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdNodesNodeDelete(
      realm: string,
      id: string,
      node: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmClientsIdNodesNodeDelete(realm, id, node, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Register a cluster node with the client   Manually register cluster node to this client - usually it’s not needed to call this directly as adapter should handle  by sending registration request to Keycloak
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {{ [key: string]: any; }} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdNodesPost(
      realm: string,
      id: string,
      requestBody: { [key: string]: any },
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmClientsIdNodesPost(realm, id, requestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get application offline session count   Returns a number of offline user sessions associated with this client   {      \"count\": number  }
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdOfflineSessionCountGet(
      realm: string,
      id: string,
      options?: any
    ): AxiosPromise<{ [key: string]: any }> {
      return localVarFp
        .realmClientsIdOfflineSessionCountGet(realm, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get offline sessions for client   Returns a list of offline user sessions associated with this client
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {number} [first] Paging offset
     * @param {number} [max] Maximum results size (defaults to 100)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdOfflineSessionsGet(
      realm: string,
      id: string,
      first?: number,
      max?: number,
      options?: any
    ): AxiosPromise<Array<{ [key: string]: any }>> {
      return localVarFp
        .realmClientsIdOfflineSessionsGet(realm, id, first, max, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} clientScopeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdOptionalClientScopesClientScopeIdDelete(
      realm: string,
      id: string,
      clientScopeId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmClientsIdOptionalClientScopesClientScopeIdDelete(
          realm,
          id,
          clientScopeId,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} clientScopeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdOptionalClientScopesClientScopeIdPut(
      realm: string,
      id: string,
      clientScopeId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmClientsIdOptionalClientScopesClientScopeIdPut(
          realm,
          id,
          clientScopeId,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get optional client scopes.
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdOptionalClientScopesGet(
      realm: string,
      id: string,
      options?: any
    ): AxiosPromise<Array<{ [key: string]: any }>> {
      return localVarFp
        .realmClientsIdOptionalClientScopesGet(realm, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Push the client’s revocation policy to its admin URL   If the client has an admin URL, push revocation policy to it.
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdPushRevocationPost(
      realm: string,
      id: string,
      options?: any
    ): AxiosPromise<GlobalRequestResult> {
      return localVarFp
        .realmClientsIdPushRevocationPost(realm, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update the client
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {ClientRepresentation} clientRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdPut(
      realm: string,
      id: string,
      clientRepresentation: ClientRepresentation,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmClientsIdPut(realm, id, clientRepresentation, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Generate a new registration access token for the client
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdRegistrationAccessTokenPost(
      realm: string,
      id: string,
      options?: any
    ): AxiosPromise<ClientRepresentation> {
      return localVarFp
        .realmClientsIdRegistrationAccessTokenPost(realm, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get a user dedicated to the service account
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdServiceAccountUserGet(
      realm: string,
      id: string,
      options?: any
    ): AxiosPromise<UserRepresentation> {
      return localVarFp
        .realmClientsIdServiceAccountUserGet(realm, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get application session count   Returns a number of user sessions associated with this client   {      \"count\": number  }
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdSessionCountGet(
      realm: string,
      id: string,
      options?: any
    ): AxiosPromise<{ [key: string]: any }> {
      return localVarFp
        .realmClientsIdSessionCountGet(realm, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Test if registered cluster nodes are available   Tests availability by sending \'ping\' request to all cluster nodes.
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdTestNodesAvailableGet(
      realm: string,
      id: string,
      options?: any
    ): AxiosPromise<GlobalRequestResult> {
      return localVarFp
        .realmClientsIdTestNodesAvailableGet(realm, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get user sessions for client   Returns a list of user sessions associated with this client
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {number} [first] Paging offset
     * @param {number} [max] Maximum results size (defaults to 100)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdUserSessionsGet(
      realm: string,
      id: string,
      first?: number,
      max?: number,
      options?: any
    ): AxiosPromise<Array<{ [key: string]: any }>> {
      return localVarFp
        .realmClientsIdUserSessionsGet(realm, id, first, max, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create a new client   Client’s client_id must be unique!
     * @param {string} realm realm name (not id!)
     * @param {ClientRepresentation} clientRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsPost(
      realm: string,
      clientRepresentation: ClientRepresentation,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmClientsPost(realm, clientRepresentation, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ClientsApi - object-oriented interface
 * @export
 * @class ClientsApi
 * @extends {BaseAPI}
 */
export class ClientsApi extends BaseAPI {
  /**
   *
   * @summary Get clients belonging to the realm.
   * @param {string} realm realm name (not id!)
   * @param {string} [clientId] filter by clientId
   * @param {number} [first] the first result
   * @param {number} [max] the max results to return
   * @param {string} [q]
   * @param {boolean} [search] whether this is a search query or a getClientById query
   * @param {boolean} [viewableOnly] filter clients that cannot be viewed in full by admin
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public realmClientsGet(
    realm: string,
    clientId?: string,
    first?: number,
    max?: number,
    q?: string,
    search?: boolean,
    viewableOnly?: boolean,
    options?: AxiosRequestConfig
  ) {
    return ClientsApiFp(this.configuration)
      .realmClientsGet(
        realm,
        clientId,
        first,
        max,
        q,
        search,
        viewableOnly,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get the client secret
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client (not client-id)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public realmClientsIdClientSecretGet(
    realm: string,
    id: string,
    options?: AxiosRequestConfig
  ) {
    return ClientsApiFp(this.configuration)
      .realmClientsIdClientSecretGet(realm, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Generate a new secret for the client
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client (not client-id)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public realmClientsIdClientSecretPost(
    realm: string,
    id: string,
    options?: AxiosRequestConfig
  ) {
    return ClientsApiFp(this.configuration)
      .realmClientsIdClientSecretPost(realm, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Invalidate the rotated secret for the client
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client (not client-id)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public realmClientsIdClientSecretRotatedDelete(
    realm: string,
    id: string,
    options?: AxiosRequestConfig
  ) {
    return ClientsApiFp(this.configuration)
      .realmClientsIdClientSecretRotatedDelete(realm, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get the rotated client secret
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client (not client-id)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public realmClientsIdClientSecretRotatedGet(
    realm: string,
    id: string,
    options?: AxiosRequestConfig
  ) {
    return ClientsApiFp(this.configuration)
      .realmClientsIdClientSecretRotatedGet(realm, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client (not client-id)
   * @param {string} clientScopeId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public realmClientsIdDefaultClientScopesClientScopeIdDelete(
    realm: string,
    id: string,
    clientScopeId: string,
    options?: AxiosRequestConfig
  ) {
    return ClientsApiFp(this.configuration)
      .realmClientsIdDefaultClientScopesClientScopeIdDelete(
        realm,
        id,
        clientScopeId,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client (not client-id)
   * @param {string} clientScopeId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public realmClientsIdDefaultClientScopesClientScopeIdPut(
    realm: string,
    id: string,
    clientScopeId: string,
    options?: AxiosRequestConfig
  ) {
    return ClientsApiFp(this.configuration)
      .realmClientsIdDefaultClientScopesClientScopeIdPut(
        realm,
        id,
        clientScopeId,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get default client scopes.
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client (not client-id)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public realmClientsIdDefaultClientScopesGet(
    realm: string,
    id: string,
    options?: AxiosRequestConfig
  ) {
    return ClientsApiFp(this.configuration)
      .realmClientsIdDefaultClientScopesGet(realm, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete the client
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client (not client-id)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public realmClientsIdDelete(
    realm: string,
    id: string,
    options?: AxiosRequestConfig
  ) {
    return ClientsApiFp(this.configuration)
      .realmClientsIdDelete(realm, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create JSON with payload of example access token
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client (not client-id)
   * @param {string} [scope]
   * @param {string} [userId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public realmClientsIdEvaluateScopesGenerateExampleAccessTokenGet(
    realm: string,
    id: string,
    scope?: string,
    userId?: string,
    options?: AxiosRequestConfig
  ) {
    return ClientsApiFp(this.configuration)
      .realmClientsIdEvaluateScopesGenerateExampleAccessTokenGet(
        realm,
        id,
        scope,
        userId,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create JSON with payload of example id token
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client (not client-id)
   * @param {string} [scope]
   * @param {string} [userId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public realmClientsIdEvaluateScopesGenerateExampleIdTokenGet(
    realm: string,
    id: string,
    scope?: string,
    userId?: string,
    options?: AxiosRequestConfig
  ) {
    return ClientsApiFp(this.configuration)
      .realmClientsIdEvaluateScopesGenerateExampleIdTokenGet(
        realm,
        id,
        scope,
        userId,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create JSON with payload of example user info
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client (not client-id)
   * @param {string} [scope]
   * @param {string} [userId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public realmClientsIdEvaluateScopesGenerateExampleUserinfoGet(
    realm: string,
    id: string,
    scope?: string,
    userId?: string,
    options?: AxiosRequestConfig
  ) {
    return ClientsApiFp(this.configuration)
      .realmClientsIdEvaluateScopesGenerateExampleUserinfoGet(
        realm,
        id,
        scope,
        userId,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Return list of all protocol mappers, which will be used when generating tokens issued for particular client.
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client (not client-id)
   * @param {string} [scope]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public realmClientsIdEvaluateScopesProtocolMappersGet(
    realm: string,
    id: string,
    scope?: string,
    options?: AxiosRequestConfig
  ) {
    return ClientsApiFp(this.configuration)
      .realmClientsIdEvaluateScopesProtocolMappersGet(realm, id, scope, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get effective scope mapping of all roles of particular role container, which this client is defacto allowed to have in the accessToken issued for him.
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client (not client-id)
   * @param {string} roleContainerId either realm name OR client UUID
   * @param {string} [scope]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public realmClientsIdEvaluateScopesScopeMappingsRoleContainerIdGrantedGet(
    realm: string,
    id: string,
    roleContainerId: string,
    scope?: string,
    options?: AxiosRequestConfig
  ) {
    return ClientsApiFp(this.configuration)
      .realmClientsIdEvaluateScopesScopeMappingsRoleContainerIdGrantedGet(
        realm,
        id,
        roleContainerId,
        scope,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get roles, which this client doesn’t have scope for and can’t have them in the accessToken issued for him.
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client (not client-id)
   * @param {string} roleContainerId either realm name OR client UUID
   * @param {string} [scope]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public realmClientsIdEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGet(
    realm: string,
    id: string,
    roleContainerId: string,
    scope?: string,
    options?: AxiosRequestConfig
  ) {
    return ClientsApiFp(this.configuration)
      .realmClientsIdEvaluateScopesScopeMappingsRoleContainerIdNotGrantedGet(
        realm,
        id,
        roleContainerId,
        scope,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get representation of the client
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client (not client-id)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public realmClientsIdGet(
    realm: string,
    id: string,
    options?: AxiosRequestConfig
  ) {
    return ClientsApiFp(this.configuration)
      .realmClientsIdGet(realm, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client (not client-id)
   * @param {string} providerId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public realmClientsIdInstallationProvidersProviderIdGet(
    realm: string,
    id: string,
    providerId: string,
    options?: AxiosRequestConfig
  ) {
    return ClientsApiFp(this.configuration)
      .realmClientsIdInstallationProvidersProviderIdGet(
        realm,
        id,
        providerId,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Return object stating whether client Authorization permissions have been initialized or not and a reference
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client (not client-id)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public realmClientsIdManagementPermissionsGet(
    realm: string,
    id: string,
    options?: AxiosRequestConfig
  ) {
    return ClientsApiFp(this.configuration)
      .realmClientsIdManagementPermissionsGet(realm, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Return object stating whether client Authorization permissions have been initialized or not and a reference
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client (not client-id)
   * @param {ManagementPermissionReference} managementPermissionReference
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public realmClientsIdManagementPermissionsPut(
    realm: string,
    id: string,
    managementPermissionReference: ManagementPermissionReference,
    options?: AxiosRequestConfig
  ) {
    return ClientsApiFp(this.configuration)
      .realmClientsIdManagementPermissionsPut(
        realm,
        id,
        managementPermissionReference,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Unregister a cluster node from the client
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client (not client-id)
   * @param {string} node
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public realmClientsIdNodesNodeDelete(
    realm: string,
    id: string,
    node: string,
    options?: AxiosRequestConfig
  ) {
    return ClientsApiFp(this.configuration)
      .realmClientsIdNodesNodeDelete(realm, id, node, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Register a cluster node with the client   Manually register cluster node to this client - usually it’s not needed to call this directly as adapter should handle  by sending registration request to Keycloak
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client (not client-id)
   * @param {{ [key: string]: any; }} requestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public realmClientsIdNodesPost(
    realm: string,
    id: string,
    requestBody: { [key: string]: any },
    options?: AxiosRequestConfig
  ) {
    return ClientsApiFp(this.configuration)
      .realmClientsIdNodesPost(realm, id, requestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get application offline session count   Returns a number of offline user sessions associated with this client   {      \"count\": number  }
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client (not client-id)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public realmClientsIdOfflineSessionCountGet(
    realm: string,
    id: string,
    options?: AxiosRequestConfig
  ) {
    return ClientsApiFp(this.configuration)
      .realmClientsIdOfflineSessionCountGet(realm, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get offline sessions for client   Returns a list of offline user sessions associated with this client
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client (not client-id)
   * @param {number} [first] Paging offset
   * @param {number} [max] Maximum results size (defaults to 100)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public realmClientsIdOfflineSessionsGet(
    realm: string,
    id: string,
    first?: number,
    max?: number,
    options?: AxiosRequestConfig
  ) {
    return ClientsApiFp(this.configuration)
      .realmClientsIdOfflineSessionsGet(realm, id, first, max, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client (not client-id)
   * @param {string} clientScopeId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public realmClientsIdOptionalClientScopesClientScopeIdDelete(
    realm: string,
    id: string,
    clientScopeId: string,
    options?: AxiosRequestConfig
  ) {
    return ClientsApiFp(this.configuration)
      .realmClientsIdOptionalClientScopesClientScopeIdDelete(
        realm,
        id,
        clientScopeId,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client (not client-id)
   * @param {string} clientScopeId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public realmClientsIdOptionalClientScopesClientScopeIdPut(
    realm: string,
    id: string,
    clientScopeId: string,
    options?: AxiosRequestConfig
  ) {
    return ClientsApiFp(this.configuration)
      .realmClientsIdOptionalClientScopesClientScopeIdPut(
        realm,
        id,
        clientScopeId,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get optional client scopes.
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client (not client-id)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public realmClientsIdOptionalClientScopesGet(
    realm: string,
    id: string,
    options?: AxiosRequestConfig
  ) {
    return ClientsApiFp(this.configuration)
      .realmClientsIdOptionalClientScopesGet(realm, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Push the client’s revocation policy to its admin URL   If the client has an admin URL, push revocation policy to it.
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client (not client-id)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public realmClientsIdPushRevocationPost(
    realm: string,
    id: string,
    options?: AxiosRequestConfig
  ) {
    return ClientsApiFp(this.configuration)
      .realmClientsIdPushRevocationPost(realm, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update the client
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client (not client-id)
   * @param {ClientRepresentation} clientRepresentation
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public realmClientsIdPut(
    realm: string,
    id: string,
    clientRepresentation: ClientRepresentation,
    options?: AxiosRequestConfig
  ) {
    return ClientsApiFp(this.configuration)
      .realmClientsIdPut(realm, id, clientRepresentation, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Generate a new registration access token for the client
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client (not client-id)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public realmClientsIdRegistrationAccessTokenPost(
    realm: string,
    id: string,
    options?: AxiosRequestConfig
  ) {
    return ClientsApiFp(this.configuration)
      .realmClientsIdRegistrationAccessTokenPost(realm, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get a user dedicated to the service account
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client (not client-id)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public realmClientsIdServiceAccountUserGet(
    realm: string,
    id: string,
    options?: AxiosRequestConfig
  ) {
    return ClientsApiFp(this.configuration)
      .realmClientsIdServiceAccountUserGet(realm, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get application session count   Returns a number of user sessions associated with this client   {      \"count\": number  }
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client (not client-id)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public realmClientsIdSessionCountGet(
    realm: string,
    id: string,
    options?: AxiosRequestConfig
  ) {
    return ClientsApiFp(this.configuration)
      .realmClientsIdSessionCountGet(realm, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Test if registered cluster nodes are available   Tests availability by sending \'ping\' request to all cluster nodes.
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client (not client-id)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public realmClientsIdTestNodesAvailableGet(
    realm: string,
    id: string,
    options?: AxiosRequestConfig
  ) {
    return ClientsApiFp(this.configuration)
      .realmClientsIdTestNodesAvailableGet(realm, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get user sessions for client   Returns a list of user sessions associated with this client
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client (not client-id)
   * @param {number} [first] Paging offset
   * @param {number} [max] Maximum results size (defaults to 100)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public realmClientsIdUserSessionsGet(
    realm: string,
    id: string,
    first?: number,
    max?: number,
    options?: AxiosRequestConfig
  ) {
    return ClientsApiFp(this.configuration)
      .realmClientsIdUserSessionsGet(realm, id, first, max, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create a new client   Client’s client_id must be unique!
   * @param {string} realm realm name (not id!)
   * @param {ClientRepresentation} clientRepresentation
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public realmClientsPost(
    realm: string,
    clientRepresentation: ClientRepresentation,
    options?: AxiosRequestConfig
  ) {
    return ClientsApiFp(this.configuration)
      .realmClientsPost(realm, clientRepresentation, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
