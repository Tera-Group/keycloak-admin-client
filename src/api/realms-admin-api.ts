/* tslint:disable */
/* eslint-disable */
/**
 * Keycloak Admin REST API
 * This is a REST API reference for the Keycloak Admin REST API.
 *
 * The version of the OpenAPI document: 1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from '../common';
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from '../base';
// @ts-ignore
import { ClientPoliciesRepresentation } from '../model';
// @ts-ignore
import { ClientProfilesRepresentation } from '../model';
// @ts-ignore
import { ClientRepresentation } from '../model';
// @ts-ignore
import { GlobalRequestResult } from '../model';
// @ts-ignore
import { GroupRepresentation } from '../model';
// @ts-ignore
import { ManagementPermissionReference } from '../model';
// @ts-ignore
import { PartialImportRepresentation } from '../model';
// @ts-ignore
import { RealmEventsConfigRepresentation } from '../model';
// @ts-ignore
import { RealmRepresentation } from '../model';
/**
 * RealmsAdminApi - axios parameter creator
 * @export
 */
export const RealmsAdminApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Delete all admin events
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAdminEventsDelete: async (
      realm: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmAdminEventsDelete', 'realm', realm);
      const localVarPath = `/{realm}/admin-events`.replace(
        `{${'realm'}}`,
        encodeURIComponent(String(realm))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get admin events   Returns all admin events, or filters events based on URL query parameters listed here
     * @param {string} realm realm name (not id!)
     * @param {string} [authClient]
     * @param {string} [authIpAddress]
     * @param {string} [authRealm]
     * @param {string} [authUser] user id
     * @param {string} [dateFrom]
     * @param {string} [dateTo]
     * @param {number} [first]
     * @param {number} [max] Maximum results size (defaults to 100)
     * @param {Array<string>} [operationTypes]
     * @param {string} [resourcePath]
     * @param {Array<string>} [resourceTypes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAdminEventsGet: async (
      realm: string,
      authClient?: string,
      authIpAddress?: string,
      authRealm?: string,
      authUser?: string,
      dateFrom?: string,
      dateTo?: string,
      first?: number,
      max?: number,
      operationTypes?: Array<string>,
      resourcePath?: string,
      resourceTypes?: Array<string>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmAdminEventsGet', 'realm', realm);
      const localVarPath = `/{realm}/admin-events`.replace(
        `{${'realm'}}`,
        encodeURIComponent(String(realm))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (authClient !== undefined) {
        localVarQueryParameter['authClient'] = authClient;
      }

      if (authIpAddress !== undefined) {
        localVarQueryParameter['authIpAddress'] = authIpAddress;
      }

      if (authRealm !== undefined) {
        localVarQueryParameter['authRealm'] = authRealm;
      }

      if (authUser !== undefined) {
        localVarQueryParameter['authUser'] = authUser;
      }

      if (dateFrom !== undefined) {
        localVarQueryParameter['dateFrom'] = dateFrom;
      }

      if (dateTo !== undefined) {
        localVarQueryParameter['dateTo'] = dateTo;
      }

      if (first !== undefined) {
        localVarQueryParameter['first'] = first;
      }

      if (max !== undefined) {
        localVarQueryParameter['max'] = max;
      }

      if (operationTypes) {
        localVarQueryParameter['operationTypes'] = operationTypes;
      }

      if (resourcePath !== undefined) {
        localVarQueryParameter['resourcePath'] = resourcePath;
      }

      if (resourceTypes) {
        localVarQueryParameter['resourceTypes'] = resourceTypes;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Base path for importing clients under this realm.
     * @param {string} realm realm name (not id!)
     * @param {string} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientDescriptionConverterPost: async (
      realm: string,
      body: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmClientDescriptionConverterPost', 'realm', realm);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('realmClientDescriptionConverterPost', 'body', body);
      const localVarPath = `/{realm}/client-description-converter`.replace(
        `{${'realm'}}`,
        encodeURIComponent(String(realm))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'text/plain';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientPoliciesPoliciesGet: async (
      realm: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmClientPoliciesPoliciesGet', 'realm', realm);
      const localVarPath = `/{realm}/client-policies/policies`.replace(
        `{${'realm'}}`,
        encodeURIComponent(String(realm))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {ClientPoliciesRepresentation} clientPoliciesRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientPoliciesPoliciesPut: async (
      realm: string,
      clientPoliciesRepresentation: ClientPoliciesRepresentation,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmClientPoliciesPoliciesPut', 'realm', realm);
      // verify required parameter 'clientPoliciesRepresentation' is not null or undefined
      assertParamExists(
        'realmClientPoliciesPoliciesPut',
        'clientPoliciesRepresentation',
        clientPoliciesRepresentation
      );
      const localVarPath = `/{realm}/client-policies/policies`.replace(
        `{${'realm'}}`,
        encodeURIComponent(String(realm))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        clientPoliciesRepresentation,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {boolean} [includeGlobalProfiles]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientPoliciesProfilesGet: async (
      realm: string,
      includeGlobalProfiles?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmClientPoliciesProfilesGet', 'realm', realm);
      const localVarPath = `/{realm}/client-policies/profiles`.replace(
        `{${'realm'}}`,
        encodeURIComponent(String(realm))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (includeGlobalProfiles !== undefined) {
        localVarQueryParameter['include-global-profiles'] =
          includeGlobalProfiles;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {ClientProfilesRepresentation} clientProfilesRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientPoliciesProfilesPut: async (
      realm: string,
      clientProfilesRepresentation: ClientProfilesRepresentation,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmClientPoliciesProfilesPut', 'realm', realm);
      // verify required parameter 'clientProfilesRepresentation' is not null or undefined
      assertParamExists(
        'realmClientPoliciesProfilesPut',
        'clientProfilesRepresentation',
        clientProfilesRepresentation
      );
      const localVarPath = `/{realm}/client-policies/profiles`.replace(
        `{${'realm'}}`,
        encodeURIComponent(String(realm))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        clientProfilesRepresentation,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get client session stats   Returns a JSON map.
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientSessionStatsGet: async (
      realm: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmClientSessionStatsGet', 'realm', realm);
      const localVarPath = `/{realm}/client-session-stats`.replace(
        `{${'realm'}}`,
        encodeURIComponent(String(realm))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmCredentialRegistratorsGet: async (
      realm: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmCredentialRegistratorsGet', 'realm', realm);
      const localVarPath = `/{realm}/credential-registrators`.replace(
        `{${'realm'}}`,
        encodeURIComponent(String(realm))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} clientScopeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmDefaultDefaultClientScopesClientScopeIdDelete: async (
      realm: string,
      clientScopeId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmDefaultDefaultClientScopesClientScopeIdDelete',
        'realm',
        realm
      );
      // verify required parameter 'clientScopeId' is not null or undefined
      assertParamExists(
        'realmDefaultDefaultClientScopesClientScopeIdDelete',
        'clientScopeId',
        clientScopeId
      );
      const localVarPath =
        `/{realm}/default-default-client-scopes/{clientScopeId}`
          .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
          .replace(
            `{${'clientScopeId'}}`,
            encodeURIComponent(String(clientScopeId))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} clientScopeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmDefaultDefaultClientScopesClientScopeIdPut: async (
      realm: string,
      clientScopeId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmDefaultDefaultClientScopesClientScopeIdPut',
        'realm',
        realm
      );
      // verify required parameter 'clientScopeId' is not null or undefined
      assertParamExists(
        'realmDefaultDefaultClientScopesClientScopeIdPut',
        'clientScopeId',
        clientScopeId
      );
      const localVarPath =
        `/{realm}/default-default-client-scopes/{clientScopeId}`
          .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
          .replace(
            `{${'clientScopeId'}}`,
            encodeURIComponent(String(clientScopeId))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get realm default client scopes.
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmDefaultDefaultClientScopesGet: async (
      realm: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmDefaultDefaultClientScopesGet', 'realm', realm);
      const localVarPath = `/{realm}/default-default-client-scopes`.replace(
        `{${'realm'}}`,
        encodeURIComponent(String(realm))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get group hierarchy.
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmDefaultGroupsGet: async (
      realm: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmDefaultGroupsGet', 'realm', realm);
      const localVarPath = `/{realm}/default-groups`.replace(
        `{${'realm'}}`,
        encodeURIComponent(String(realm))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} groupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmDefaultGroupsGroupIdDelete: async (
      realm: string,
      groupId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmDefaultGroupsGroupIdDelete', 'realm', realm);
      // verify required parameter 'groupId' is not null or undefined
      assertParamExists('realmDefaultGroupsGroupIdDelete', 'groupId', groupId);
      const localVarPath = `/{realm}/default-groups/{groupId}`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'groupId'}}`, encodeURIComponent(String(groupId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} groupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmDefaultGroupsGroupIdPut: async (
      realm: string,
      groupId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmDefaultGroupsGroupIdPut', 'realm', realm);
      // verify required parameter 'groupId' is not null or undefined
      assertParamExists('realmDefaultGroupsGroupIdPut', 'groupId', groupId);
      const localVarPath = `/{realm}/default-groups/{groupId}`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'groupId'}}`, encodeURIComponent(String(groupId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} clientScopeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmDefaultOptionalClientScopesClientScopeIdDelete: async (
      realm: string,
      clientScopeId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmDefaultOptionalClientScopesClientScopeIdDelete',
        'realm',
        realm
      );
      // verify required parameter 'clientScopeId' is not null or undefined
      assertParamExists(
        'realmDefaultOptionalClientScopesClientScopeIdDelete',
        'clientScopeId',
        clientScopeId
      );
      const localVarPath =
        `/{realm}/default-optional-client-scopes/{clientScopeId}`
          .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
          .replace(
            `{${'clientScopeId'}}`,
            encodeURIComponent(String(clientScopeId))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} clientScopeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmDefaultOptionalClientScopesClientScopeIdPut: async (
      realm: string,
      clientScopeId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmDefaultOptionalClientScopesClientScopeIdPut',
        'realm',
        realm
      );
      // verify required parameter 'clientScopeId' is not null or undefined
      assertParamExists(
        'realmDefaultOptionalClientScopesClientScopeIdPut',
        'clientScopeId',
        clientScopeId
      );
      const localVarPath =
        `/{realm}/default-optional-client-scopes/{clientScopeId}`
          .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
          .replace(
            `{${'clientScopeId'}}`,
            encodeURIComponent(String(clientScopeId))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get realm optional client scopes.
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmDefaultOptionalClientScopesGet: async (
      realm: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmDefaultOptionalClientScopesGet', 'realm', realm);
      const localVarPath = `/{realm}/default-optional-client-scopes`.replace(
        `{${'realm'}}`,
        encodeURIComponent(String(realm))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete the realm
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmDelete: async (
      realm: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmDelete', 'realm', realm);
      const localVarPath = `/{realm}`.replace(
        `{${'realm'}}`,
        encodeURIComponent(String(realm))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the events provider configuration   Returns JSON object with events provider configuration
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmEventsConfigGet: async (
      realm: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmEventsConfigGet', 'realm', realm);
      const localVarPath = `/{realm}/events/config`.replace(
        `{${'realm'}}`,
        encodeURIComponent(String(realm))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update the events provider   Change the events provider and/or its configuration
     * @param {string} realm realm name (not id!)
     * @param {RealmEventsConfigRepresentation} realmEventsConfigRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmEventsConfigPut: async (
      realm: string,
      realmEventsConfigRepresentation: RealmEventsConfigRepresentation,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmEventsConfigPut', 'realm', realm);
      // verify required parameter 'realmEventsConfigRepresentation' is not null or undefined
      assertParamExists(
        'realmEventsConfigPut',
        'realmEventsConfigRepresentation',
        realmEventsConfigRepresentation
      );
      const localVarPath = `/{realm}/events/config`.replace(
        `{${'realm'}}`,
        encodeURIComponent(String(realm))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        realmEventsConfigRepresentation,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete all events
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmEventsDelete: async (
      realm: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmEventsDelete', 'realm', realm);
      const localVarPath = `/{realm}/events`.replace(
        `{${'realm'}}`,
        encodeURIComponent(String(realm))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get events   Returns all events, or filters them based on URL query parameters listed here
     * @param {string} realm realm name (not id!)
     * @param {string} [client] App or oauth client name
     * @param {string} [dateFrom] From date
     * @param {string} [dateTo] To date
     * @param {number} [first] Paging offset
     * @param {string} [ipAddress] IP address
     * @param {number} [max] Maximum results size (defaults to 100)
     * @param {Array<string>} [type] The types of events to return
     * @param {string} [user] User id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmEventsGet: async (
      realm: string,
      client?: string,
      dateFrom?: string,
      dateTo?: string,
      first?: number,
      ipAddress?: string,
      max?: number,
      type?: Array<string>,
      user?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmEventsGet', 'realm', realm);
      const localVarPath = `/{realm}/events`.replace(
        `{${'realm'}}`,
        encodeURIComponent(String(realm))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (client !== undefined) {
        localVarQueryParameter['client'] = client;
      }

      if (dateFrom !== undefined) {
        localVarQueryParameter['dateFrom'] = dateFrom;
      }

      if (dateTo !== undefined) {
        localVarQueryParameter['dateTo'] = dateTo;
      }

      if (first !== undefined) {
        localVarQueryParameter['first'] = first;
      }

      if (ipAddress !== undefined) {
        localVarQueryParameter['ipAddress'] = ipAddress;
      }

      if (max !== undefined) {
        localVarQueryParameter['max'] = max;
      }

      if (type) {
        localVarQueryParameter['type'] = type;
      }

      if (user !== undefined) {
        localVarQueryParameter['user'] = user;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the top-level representation of the realm   It will not include nested information like User and Client representations.
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmGet: async (
      realm: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmGet', 'realm', realm);
      const localVarPath = `/{realm}`.replace(
        `{${'realm'}}`,
        encodeURIComponent(String(realm))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmGroupByPathPathGet: async (
      realm: string,
      path: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmGroupByPathPathGet', 'realm', realm);
      // verify required parameter 'path' is not null or undefined
      assertParamExists('realmGroupByPathPathGet', 'path', path);
      const localVarPath = `/{realm}/group-by-path/{path}`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'path'}}`, encodeURIComponent(String(path)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmLocalizationGet: async (
      realm: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmLocalizationGet', 'realm', realm);
      const localVarPath = `/{realm}/localization`.replace(
        `{${'realm'}}`,
        encodeURIComponent(String(realm))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} locale
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmLocalizationLocaleDelete: async (
      realm: string,
      locale: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmLocalizationLocaleDelete', 'realm', realm);
      // verify required parameter 'locale' is not null or undefined
      assertParamExists('realmLocalizationLocaleDelete', 'locale', locale);
      const localVarPath = `/{realm}/localization/{locale}`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'locale'}}`, encodeURIComponent(String(locale)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} locale
     * @param {boolean} [useRealmDefaultLocaleFallback]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmLocalizationLocaleGet: async (
      realm: string,
      locale: string,
      useRealmDefaultLocaleFallback?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmLocalizationLocaleGet', 'realm', realm);
      // verify required parameter 'locale' is not null or undefined
      assertParamExists('realmLocalizationLocaleGet', 'locale', locale);
      const localVarPath = `/{realm}/localization/{locale}`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'locale'}}`, encodeURIComponent(String(locale)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (useRealmDefaultLocaleFallback !== undefined) {
        localVarQueryParameter['useRealmDefaultLocaleFallback'] =
          useRealmDefaultLocaleFallback;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} locale
     * @param {string} key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmLocalizationLocaleKeyDelete: async (
      realm: string,
      locale: string,
      key: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmLocalizationLocaleKeyDelete', 'realm', realm);
      // verify required parameter 'locale' is not null or undefined
      assertParamExists('realmLocalizationLocaleKeyDelete', 'locale', locale);
      // verify required parameter 'key' is not null or undefined
      assertParamExists('realmLocalizationLocaleKeyDelete', 'key', key);
      const localVarPath = `/{realm}/localization/{locale}/{key}`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'locale'}}`, encodeURIComponent(String(locale)))
        .replace(`{${'key'}}`, encodeURIComponent(String(key)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} locale
     * @param {string} key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmLocalizationLocaleKeyGet: async (
      realm: string,
      locale: string,
      key: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmLocalizationLocaleKeyGet', 'realm', realm);
      // verify required parameter 'locale' is not null or undefined
      assertParamExists('realmLocalizationLocaleKeyGet', 'locale', locale);
      // verify required parameter 'key' is not null or undefined
      assertParamExists('realmLocalizationLocaleKeyGet', 'key', key);
      const localVarPath = `/{realm}/localization/{locale}/{key}`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'locale'}}`, encodeURIComponent(String(locale)))
        .replace(`{${'key'}}`, encodeURIComponent(String(key)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} locale
     * @param {string} key
     * @param {string} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmLocalizationLocaleKeyPut: async (
      realm: string,
      locale: string,
      key: string,
      body: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmLocalizationLocaleKeyPut', 'realm', realm);
      // verify required parameter 'locale' is not null or undefined
      assertParamExists('realmLocalizationLocaleKeyPut', 'locale', locale);
      // verify required parameter 'key' is not null or undefined
      assertParamExists('realmLocalizationLocaleKeyPut', 'key', key);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('realmLocalizationLocaleKeyPut', 'body', body);
      const localVarPath = `/{realm}/localization/{locale}/{key}`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'locale'}}`, encodeURIComponent(String(locale)))
        .replace(`{${'key'}}`, encodeURIComponent(String(key)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'text/plain';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} locale
     * @param {{ [key: string]: any; }} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmLocalizationLocalePost: async (
      realm: string,
      locale: string,
      requestBody: { [key: string]: any },
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmLocalizationLocalePost', 'realm', realm);
      // verify required parameter 'locale' is not null or undefined
      assertParamExists('realmLocalizationLocalePost', 'locale', locale);
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists(
        'realmLocalizationLocalePost',
        'requestBody',
        requestBody
      );
      const localVarPath = `/{realm}/localization/{locale}`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'locale'}}`, encodeURIComponent(String(locale)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Removes all user sessions.
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmLogoutAllPost: async (
      realm: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmLogoutAllPost', 'realm', realm);
      const localVarPath = `/{realm}/logout-all`.replace(
        `{${'realm'}}`,
        encodeURIComponent(String(realm))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Partial export of existing realm into a JSON file.
     * @param {string} realm realm name (not id!)
     * @param {boolean} [exportClients]
     * @param {boolean} [exportGroupsAndRoles]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmPartialExportPost: async (
      realm: string,
      exportClients?: boolean,
      exportGroupsAndRoles?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmPartialExportPost', 'realm', realm);
      const localVarPath = `/{realm}/partial-export`.replace(
        `{${'realm'}}`,
        encodeURIComponent(String(realm))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (exportClients !== undefined) {
        localVarQueryParameter['exportClients'] = exportClients;
      }

      if (exportGroupsAndRoles !== undefined) {
        localVarQueryParameter['exportGroupsAndRoles'] = exportGroupsAndRoles;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Partial import from a JSON file to an existing realm.
     * @param {string} realm realm name (not id!)
     * @param {PartialImportRepresentation} partialImportRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmPartialImportPost: async (
      realm: string,
      partialImportRepresentation: PartialImportRepresentation,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmPartialImportPost', 'realm', realm);
      // verify required parameter 'partialImportRepresentation' is not null or undefined
      assertParamExists(
        'realmPartialImportPost',
        'partialImportRepresentation',
        partialImportRepresentation
      );
      const localVarPath = `/{realm}/partialImport`.replace(
        `{${'realm'}}`,
        encodeURIComponent(String(realm))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        partialImportRepresentation,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Push the realms revocation policy to any client that has an admin url associated with it.
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmPushRevocationPost: async (
      realm: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmPushRevocationPost', 'realm', realm);
      const localVarPath = `/{realm}/push-revocation`.replace(
        `{${'realm'}}`,
        encodeURIComponent(String(realm))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update the top-level information of the realm   Any user, roles or client information in the representation  will be ignored.
     * @param {string} realm realm name (not id!)
     * @param {RealmRepresentation} realmRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmPut: async (
      realm: string,
      realmRepresentation: RealmRepresentation,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmPut', 'realm', realm);
      // verify required parameter 'realmRepresentation' is not null or undefined
      assertParamExists('realmPut', 'realmRepresentation', realmRepresentation);
      const localVarPath = `/{realm}`.replace(
        `{${'realm'}}`,
        encodeURIComponent(String(realm))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        realmRepresentation,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Remove a specific user session.
     * @param {string} realm realm name (not id!)
     * @param {string} session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmSessionsSessionDelete: async (
      realm: string,
      session: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmSessionsSessionDelete', 'realm', realm);
      // verify required parameter 'session' is not null or undefined
      assertParamExists('realmSessionsSessionDelete', 'session', session);
      const localVarPath = `/{realm}/sessions/{session}`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'session'}}`, encodeURIComponent(String(session)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {{ [key: string]: any; }} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmTestSMTPConnectionPost: async (
      realm: string,
      requestBody: { [key: string]: any },
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmTestSMTPConnectionPost', 'realm', realm);
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists(
        'realmTestSMTPConnectionPost',
        'requestBody',
        requestBody
      );
      const localVarPath = `/{realm}/testSMTPConnection`.replace(
        `{${'realm'}}`,
        encodeURIComponent(String(realm))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersManagementPermissionsGet: async (
      realm: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmUsersManagementPermissionsGet', 'realm', realm);
      const localVarPath = `/{realm}/users-management-permissions`.replace(
        `{${'realm'}}`,
        encodeURIComponent(String(realm))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {ManagementPermissionReference} managementPermissionReference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersManagementPermissionsPut: async (
      realm: string,
      managementPermissionReference: ManagementPermissionReference,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmUsersManagementPermissionsPut', 'realm', realm);
      // verify required parameter 'managementPermissionReference' is not null or undefined
      assertParamExists(
        'realmUsersManagementPermissionsPut',
        'managementPermissionReference',
        managementPermissionReference
      );
      const localVarPath = `/{realm}/users-management-permissions`.replace(
        `{${'realm'}}`,
        encodeURIComponent(String(realm))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        managementPermissionReference,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Import a realm   Imports a realm from a full representation of that realm.
     * @param {RealmRepresentation} realmRepresentation JSON representation of the realm
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rootPost: async (
      realmRepresentation: RealmRepresentation,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realmRepresentation' is not null or undefined
      assertParamExists('rootPost', 'realmRepresentation', realmRepresentation);
      const localVarPath = `/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        realmRepresentation,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * RealmsAdminApi - functional programming interface
 * @export
 */
export const RealmsAdminApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    RealmsAdminApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Delete all admin events
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmAdminEventsDelete(
      realm: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmAdminEventsDelete(realm, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get admin events   Returns all admin events, or filters events based on URL query parameters listed here
     * @param {string} realm realm name (not id!)
     * @param {string} [authClient]
     * @param {string} [authIpAddress]
     * @param {string} [authRealm]
     * @param {string} [authUser] user id
     * @param {string} [dateFrom]
     * @param {string} [dateTo]
     * @param {number} [first]
     * @param {number} [max] Maximum results size (defaults to 100)
     * @param {Array<string>} [operationTypes]
     * @param {string} [resourcePath]
     * @param {Array<string>} [resourceTypes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmAdminEventsGet(
      realm: string,
      authClient?: string,
      authIpAddress?: string,
      authRealm?: string,
      authUser?: string,
      dateFrom?: string,
      dateTo?: string,
      first?: number,
      max?: number,
      operationTypes?: Array<string>,
      resourcePath?: string,
      resourceTypes?: Array<string>,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<{ [key: string]: any }>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmAdminEventsGet(
          realm,
          authClient,
          authIpAddress,
          authRealm,
          authUser,
          dateFrom,
          dateTo,
          first,
          max,
          operationTypes,
          resourcePath,
          resourceTypes,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Base path for importing clients under this realm.
     * @param {string} realm realm name (not id!)
     * @param {string} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientDescriptionConverterPost(
      realm: string,
      body: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ClientRepresentation>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientDescriptionConverterPost(
          realm,
          body,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientPoliciesPoliciesGet(
      realm: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ClientPoliciesRepresentation>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientPoliciesPoliciesGet(
          realm,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {ClientPoliciesRepresentation} clientPoliciesRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientPoliciesPoliciesPut(
      realm: string,
      clientPoliciesRepresentation: ClientPoliciesRepresentation,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientPoliciesPoliciesPut(
          realm,
          clientPoliciesRepresentation,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {boolean} [includeGlobalProfiles]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientPoliciesProfilesGet(
      realm: string,
      includeGlobalProfiles?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ClientProfilesRepresentation>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientPoliciesProfilesGet(
          realm,
          includeGlobalProfiles,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {ClientProfilesRepresentation} clientProfilesRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientPoliciesProfilesPut(
      realm: string,
      clientProfilesRepresentation: ClientProfilesRepresentation,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientPoliciesProfilesPut(
          realm,
          clientProfilesRepresentation,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get client session stats   Returns a JSON map.
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientSessionStatsGet(
      realm: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<{ [key: string]: any }>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientSessionStatsGet(
          realm,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmCredentialRegistratorsGet(
      realm: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<{ [key: string]: any }>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmCredentialRegistratorsGet(
          realm,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} clientScopeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmDefaultDefaultClientScopesClientScopeIdDelete(
      realm: string,
      clientScopeId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmDefaultDefaultClientScopesClientScopeIdDelete(
          realm,
          clientScopeId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} clientScopeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmDefaultDefaultClientScopesClientScopeIdPut(
      realm: string,
      clientScopeId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmDefaultDefaultClientScopesClientScopeIdPut(
          realm,
          clientScopeId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get realm default client scopes.
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmDefaultDefaultClientScopesGet(
      realm: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<{ [key: string]: any }>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmDefaultDefaultClientScopesGet(
          realm,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get group hierarchy.
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmDefaultGroupsGet(
      realm: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<{ [key: string]: any }>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmDefaultGroupsGet(realm, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} groupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmDefaultGroupsGroupIdDelete(
      realm: string,
      groupId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmDefaultGroupsGroupIdDelete(
          realm,
          groupId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} groupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmDefaultGroupsGroupIdPut(
      realm: string,
      groupId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmDefaultGroupsGroupIdPut(
          realm,
          groupId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} clientScopeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmDefaultOptionalClientScopesClientScopeIdDelete(
      realm: string,
      clientScopeId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmDefaultOptionalClientScopesClientScopeIdDelete(
          realm,
          clientScopeId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} clientScopeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmDefaultOptionalClientScopesClientScopeIdPut(
      realm: string,
      clientScopeId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmDefaultOptionalClientScopesClientScopeIdPut(
          realm,
          clientScopeId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get realm optional client scopes.
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmDefaultOptionalClientScopesGet(
      realm: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<{ [key: string]: any }>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmDefaultOptionalClientScopesGet(
          realm,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Delete the realm
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmDelete(
      realm: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.realmDelete(
        realm,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get the events provider configuration   Returns JSON object with events provider configuration
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmEventsConfigGet(
      realm: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<RealmEventsConfigRepresentation>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmEventsConfigGet(realm, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Update the events provider   Change the events provider and/or its configuration
     * @param {string} realm realm name (not id!)
     * @param {RealmEventsConfigRepresentation} realmEventsConfigRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmEventsConfigPut(
      realm: string,
      realmEventsConfigRepresentation: RealmEventsConfigRepresentation,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmEventsConfigPut(
          realm,
          realmEventsConfigRepresentation,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Delete all events
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmEventsDelete(
      realm: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmEventsDelete(realm, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get events   Returns all events, or filters them based on URL query parameters listed here
     * @param {string} realm realm name (not id!)
     * @param {string} [client] App or oauth client name
     * @param {string} [dateFrom] From date
     * @param {string} [dateTo] To date
     * @param {number} [first] Paging offset
     * @param {string} [ipAddress] IP address
     * @param {number} [max] Maximum results size (defaults to 100)
     * @param {Array<string>} [type] The types of events to return
     * @param {string} [user] User id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmEventsGet(
      realm: string,
      client?: string,
      dateFrom?: string,
      dateTo?: string,
      first?: number,
      ipAddress?: string,
      max?: number,
      type?: Array<string>,
      user?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<{ [key: string]: any }>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.realmEventsGet(
        realm,
        client,
        dateFrom,
        dateTo,
        first,
        ipAddress,
        max,
        type,
        user,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get the top-level representation of the realm   It will not include nested information like User and Client representations.
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmGet(
      realm: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<RealmRepresentation>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.realmGet(
        realm,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmGroupByPathPathGet(
      realm: string,
      path: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GroupRepresentation>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmGroupByPathPathGet(
          realm,
          path,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmLocalizationGet(
      realm: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<{ [key: string]: any }>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmLocalizationGet(realm, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} locale
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmLocalizationLocaleDelete(
      realm: string,
      locale: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmLocalizationLocaleDelete(
          realm,
          locale,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} locale
     * @param {boolean} [useRealmDefaultLocaleFallback]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmLocalizationLocaleGet(
      realm: string,
      locale: string,
      useRealmDefaultLocaleFallback?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: any }>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmLocalizationLocaleGet(
          realm,
          locale,
          useRealmDefaultLocaleFallback,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} locale
     * @param {string} key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmLocalizationLocaleKeyDelete(
      realm: string,
      locale: string,
      key: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmLocalizationLocaleKeyDelete(
          realm,
          locale,
          key,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} locale
     * @param {string} key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmLocalizationLocaleKeyGet(
      realm: string,
      locale: string,
      key: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmLocalizationLocaleKeyGet(
          realm,
          locale,
          key,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} locale
     * @param {string} key
     * @param {string} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmLocalizationLocaleKeyPut(
      realm: string,
      locale: string,
      key: string,
      body: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmLocalizationLocaleKeyPut(
          realm,
          locale,
          key,
          body,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} locale
     * @param {{ [key: string]: any; }} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmLocalizationLocalePost(
      realm: string,
      locale: string,
      requestBody: { [key: string]: any },
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmLocalizationLocalePost(
          realm,
          locale,
          requestBody,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Removes all user sessions.
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmLogoutAllPost(
      realm: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GlobalRequestResult>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmLogoutAllPost(realm, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Partial export of existing realm into a JSON file.
     * @param {string} realm realm name (not id!)
     * @param {boolean} [exportClients]
     * @param {boolean} [exportGroupsAndRoles]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmPartialExportPost(
      realm: string,
      exportClients?: boolean,
      exportGroupsAndRoles?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<RealmRepresentation>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmPartialExportPost(
          realm,
          exportClients,
          exportGroupsAndRoles,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Partial import from a JSON file to an existing realm.
     * @param {string} realm realm name (not id!)
     * @param {PartialImportRepresentation} partialImportRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmPartialImportPost(
      realm: string,
      partialImportRepresentation: PartialImportRepresentation,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmPartialImportPost(
          realm,
          partialImportRepresentation,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Push the realms revocation policy to any client that has an admin url associated with it.
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmPushRevocationPost(
      realm: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmPushRevocationPost(realm, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Update the top-level information of the realm   Any user, roles or client information in the representation  will be ignored.
     * @param {string} realm realm name (not id!)
     * @param {RealmRepresentation} realmRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmPut(
      realm: string,
      realmRepresentation: RealmRepresentation,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.realmPut(
        realm,
        realmRepresentation,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Remove a specific user session.
     * @param {string} realm realm name (not id!)
     * @param {string} session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmSessionsSessionDelete(
      realm: string,
      session: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmSessionsSessionDelete(
          realm,
          session,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {{ [key: string]: any; }} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmTestSMTPConnectionPost(
      realm: string,
      requestBody: { [key: string]: any },
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmTestSMTPConnectionPost(
          realm,
          requestBody,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmUsersManagementPermissionsGet(
      realm: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ManagementPermissionReference>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmUsersManagementPermissionsGet(
          realm,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {ManagementPermissionReference} managementPermissionReference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmUsersManagementPermissionsPut(
      realm: string,
      managementPermissionReference: ManagementPermissionReference,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ManagementPermissionReference>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmUsersManagementPermissionsPut(
          realm,
          managementPermissionReference,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Import a realm   Imports a realm from a full representation of that realm.
     * @param {RealmRepresentation} realmRepresentation JSON representation of the realm
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async rootPost(
      realmRepresentation: RealmRepresentation,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.rootPost(
        realmRepresentation,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * RealmsAdminApi - factory interface
 * @export
 */
export const RealmsAdminApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = RealmsAdminApiFp(configuration);
  return {
    /**
     *
     * @summary Delete all admin events
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAdminEventsDelete(realm: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .realmAdminEventsDelete(realm, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get admin events   Returns all admin events, or filters events based on URL query parameters listed here
     * @param {string} realm realm name (not id!)
     * @param {string} [authClient]
     * @param {string} [authIpAddress]
     * @param {string} [authRealm]
     * @param {string} [authUser] user id
     * @param {string} [dateFrom]
     * @param {string} [dateTo]
     * @param {number} [first]
     * @param {number} [max] Maximum results size (defaults to 100)
     * @param {Array<string>} [operationTypes]
     * @param {string} [resourcePath]
     * @param {Array<string>} [resourceTypes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAdminEventsGet(
      realm: string,
      authClient?: string,
      authIpAddress?: string,
      authRealm?: string,
      authUser?: string,
      dateFrom?: string,
      dateTo?: string,
      first?: number,
      max?: number,
      operationTypes?: Array<string>,
      resourcePath?: string,
      resourceTypes?: Array<string>,
      options?: any
    ): AxiosPromise<Array<{ [key: string]: any }>> {
      return localVarFp
        .realmAdminEventsGet(
          realm,
          authClient,
          authIpAddress,
          authRealm,
          authUser,
          dateFrom,
          dateTo,
          first,
          max,
          operationTypes,
          resourcePath,
          resourceTypes,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Base path for importing clients under this realm.
     * @param {string} realm realm name (not id!)
     * @param {string} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientDescriptionConverterPost(
      realm: string,
      body: string,
      options?: any
    ): AxiosPromise<ClientRepresentation> {
      return localVarFp
        .realmClientDescriptionConverterPost(realm, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientPoliciesPoliciesGet(
      realm: string,
      options?: any
    ): AxiosPromise<ClientPoliciesRepresentation> {
      return localVarFp
        .realmClientPoliciesPoliciesGet(realm, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {ClientPoliciesRepresentation} clientPoliciesRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientPoliciesPoliciesPut(
      realm: string,
      clientPoliciesRepresentation: ClientPoliciesRepresentation,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmClientPoliciesPoliciesPut(
          realm,
          clientPoliciesRepresentation,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {boolean} [includeGlobalProfiles]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientPoliciesProfilesGet(
      realm: string,
      includeGlobalProfiles?: boolean,
      options?: any
    ): AxiosPromise<ClientProfilesRepresentation> {
      return localVarFp
        .realmClientPoliciesProfilesGet(realm, includeGlobalProfiles, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {ClientProfilesRepresentation} clientProfilesRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientPoliciesProfilesPut(
      realm: string,
      clientProfilesRepresentation: ClientProfilesRepresentation,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmClientPoliciesProfilesPut(
          realm,
          clientProfilesRepresentation,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get client session stats   Returns a JSON map.
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientSessionStatsGet(
      realm: string,
      options?: any
    ): AxiosPromise<Array<{ [key: string]: any }>> {
      return localVarFp
        .realmClientSessionStatsGet(realm, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmCredentialRegistratorsGet(
      realm: string,
      options?: any
    ): AxiosPromise<Array<{ [key: string]: any }>> {
      return localVarFp
        .realmCredentialRegistratorsGet(realm, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} clientScopeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmDefaultDefaultClientScopesClientScopeIdDelete(
      realm: string,
      clientScopeId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmDefaultDefaultClientScopesClientScopeIdDelete(
          realm,
          clientScopeId,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} clientScopeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmDefaultDefaultClientScopesClientScopeIdPut(
      realm: string,
      clientScopeId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmDefaultDefaultClientScopesClientScopeIdPut(
          realm,
          clientScopeId,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get realm default client scopes.
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmDefaultDefaultClientScopesGet(
      realm: string,
      options?: any
    ): AxiosPromise<Array<{ [key: string]: any }>> {
      return localVarFp
        .realmDefaultDefaultClientScopesGet(realm, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get group hierarchy.
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmDefaultGroupsGet(
      realm: string,
      options?: any
    ): AxiosPromise<Array<{ [key: string]: any }>> {
      return localVarFp
        .realmDefaultGroupsGet(realm, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} groupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmDefaultGroupsGroupIdDelete(
      realm: string,
      groupId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmDefaultGroupsGroupIdDelete(realm, groupId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} groupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmDefaultGroupsGroupIdPut(
      realm: string,
      groupId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmDefaultGroupsGroupIdPut(realm, groupId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} clientScopeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmDefaultOptionalClientScopesClientScopeIdDelete(
      realm: string,
      clientScopeId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmDefaultOptionalClientScopesClientScopeIdDelete(
          realm,
          clientScopeId,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} clientScopeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmDefaultOptionalClientScopesClientScopeIdPut(
      realm: string,
      clientScopeId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmDefaultOptionalClientScopesClientScopeIdPut(
          realm,
          clientScopeId,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get realm optional client scopes.
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmDefaultOptionalClientScopesGet(
      realm: string,
      options?: any
    ): AxiosPromise<Array<{ [key: string]: any }>> {
      return localVarFp
        .realmDefaultOptionalClientScopesGet(realm, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete the realm
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmDelete(realm: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .realmDelete(realm, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get the events provider configuration   Returns JSON object with events provider configuration
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmEventsConfigGet(
      realm: string,
      options?: any
    ): AxiosPromise<RealmEventsConfigRepresentation> {
      return localVarFp
        .realmEventsConfigGet(realm, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update the events provider   Change the events provider and/or its configuration
     * @param {string} realm realm name (not id!)
     * @param {RealmEventsConfigRepresentation} realmEventsConfigRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmEventsConfigPut(
      realm: string,
      realmEventsConfigRepresentation: RealmEventsConfigRepresentation,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmEventsConfigPut(realm, realmEventsConfigRepresentation, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete all events
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmEventsDelete(realm: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .realmEventsDelete(realm, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get events   Returns all events, or filters them based on URL query parameters listed here
     * @param {string} realm realm name (not id!)
     * @param {string} [client] App or oauth client name
     * @param {string} [dateFrom] From date
     * @param {string} [dateTo] To date
     * @param {number} [first] Paging offset
     * @param {string} [ipAddress] IP address
     * @param {number} [max] Maximum results size (defaults to 100)
     * @param {Array<string>} [type] The types of events to return
     * @param {string} [user] User id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmEventsGet(
      realm: string,
      client?: string,
      dateFrom?: string,
      dateTo?: string,
      first?: number,
      ipAddress?: string,
      max?: number,
      type?: Array<string>,
      user?: string,
      options?: any
    ): AxiosPromise<Array<{ [key: string]: any }>> {
      return localVarFp
        .realmEventsGet(
          realm,
          client,
          dateFrom,
          dateTo,
          first,
          ipAddress,
          max,
          type,
          user,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get the top-level representation of the realm   It will not include nested information like User and Client representations.
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmGet(realm: string, options?: any): AxiosPromise<RealmRepresentation> {
      return localVarFp
        .realmGet(realm, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmGroupByPathPathGet(
      realm: string,
      path: string,
      options?: any
    ): AxiosPromise<GroupRepresentation> {
      return localVarFp
        .realmGroupByPathPathGet(realm, path, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmLocalizationGet(
      realm: string,
      options?: any
    ): AxiosPromise<Array<{ [key: string]: any }>> {
      return localVarFp
        .realmLocalizationGet(realm, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} locale
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmLocalizationLocaleDelete(
      realm: string,
      locale: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmLocalizationLocaleDelete(realm, locale, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} locale
     * @param {boolean} [useRealmDefaultLocaleFallback]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmLocalizationLocaleGet(
      realm: string,
      locale: string,
      useRealmDefaultLocaleFallback?: boolean,
      options?: any
    ): AxiosPromise<{ [key: string]: any }> {
      return localVarFp
        .realmLocalizationLocaleGet(
          realm,
          locale,
          useRealmDefaultLocaleFallback,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} locale
     * @param {string} key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmLocalizationLocaleKeyDelete(
      realm: string,
      locale: string,
      key: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmLocalizationLocaleKeyDelete(realm, locale, key, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} locale
     * @param {string} key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmLocalizationLocaleKeyGet(
      realm: string,
      locale: string,
      key: string,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .realmLocalizationLocaleKeyGet(realm, locale, key, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} locale
     * @param {string} key
     * @param {string} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmLocalizationLocaleKeyPut(
      realm: string,
      locale: string,
      key: string,
      body: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmLocalizationLocaleKeyPut(realm, locale, key, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} locale
     * @param {{ [key: string]: any; }} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmLocalizationLocalePost(
      realm: string,
      locale: string,
      requestBody: { [key: string]: any },
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmLocalizationLocalePost(realm, locale, requestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Removes all user sessions.
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmLogoutAllPost(
      realm: string,
      options?: any
    ): AxiosPromise<GlobalRequestResult> {
      return localVarFp
        .realmLogoutAllPost(realm, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Partial export of existing realm into a JSON file.
     * @param {string} realm realm name (not id!)
     * @param {boolean} [exportClients]
     * @param {boolean} [exportGroupsAndRoles]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmPartialExportPost(
      realm: string,
      exportClients?: boolean,
      exportGroupsAndRoles?: boolean,
      options?: any
    ): AxiosPromise<RealmRepresentation> {
      return localVarFp
        .realmPartialExportPost(
          realm,
          exportClients,
          exportGroupsAndRoles,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Partial import from a JSON file to an existing realm.
     * @param {string} realm realm name (not id!)
     * @param {PartialImportRepresentation} partialImportRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmPartialImportPost(
      realm: string,
      partialImportRepresentation: PartialImportRepresentation,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmPartialImportPost(realm, partialImportRepresentation, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Push the realms revocation policy to any client that has an admin url associated with it.
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmPushRevocationPost(realm: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .realmPushRevocationPost(realm, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update the top-level information of the realm   Any user, roles or client information in the representation  will be ignored.
     * @param {string} realm realm name (not id!)
     * @param {RealmRepresentation} realmRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmPut(
      realm: string,
      realmRepresentation: RealmRepresentation,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmPut(realm, realmRepresentation, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Remove a specific user session.
     * @param {string} realm realm name (not id!)
     * @param {string} session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmSessionsSessionDelete(
      realm: string,
      session: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmSessionsSessionDelete(realm, session, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {{ [key: string]: any; }} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmTestSMTPConnectionPost(
      realm: string,
      requestBody: { [key: string]: any },
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmTestSMTPConnectionPost(realm, requestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersManagementPermissionsGet(
      realm: string,
      options?: any
    ): AxiosPromise<ManagementPermissionReference> {
      return localVarFp
        .realmUsersManagementPermissionsGet(realm, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {ManagementPermissionReference} managementPermissionReference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmUsersManagementPermissionsPut(
      realm: string,
      managementPermissionReference: ManagementPermissionReference,
      options?: any
    ): AxiosPromise<ManagementPermissionReference> {
      return localVarFp
        .realmUsersManagementPermissionsPut(
          realm,
          managementPermissionReference,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Import a realm   Imports a realm from a full representation of that realm.
     * @param {RealmRepresentation} realmRepresentation JSON representation of the realm
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rootPost(
      realmRepresentation: RealmRepresentation,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .rootPost(realmRepresentation, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * RealmsAdminApi - object-oriented interface
 * @export
 * @class RealmsAdminApi
 * @extends {BaseAPI}
 */
export class RealmsAdminApi extends BaseAPI {
  /**
   *
   * @summary Delete all admin events
   * @param {string} realm realm name (not id!)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealmsAdminApi
   */
  public realmAdminEventsDelete(realm: string, options?: AxiosRequestConfig) {
    return RealmsAdminApiFp(this.configuration)
      .realmAdminEventsDelete(realm, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get admin events   Returns all admin events, or filters events based on URL query parameters listed here
   * @param {string} realm realm name (not id!)
   * @param {string} [authClient]
   * @param {string} [authIpAddress]
   * @param {string} [authRealm]
   * @param {string} [authUser] user id
   * @param {string} [dateFrom]
   * @param {string} [dateTo]
   * @param {number} [first]
   * @param {number} [max] Maximum results size (defaults to 100)
   * @param {Array<string>} [operationTypes]
   * @param {string} [resourcePath]
   * @param {Array<string>} [resourceTypes]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealmsAdminApi
   */
  public realmAdminEventsGet(
    realm: string,
    authClient?: string,
    authIpAddress?: string,
    authRealm?: string,
    authUser?: string,
    dateFrom?: string,
    dateTo?: string,
    first?: number,
    max?: number,
    operationTypes?: Array<string>,
    resourcePath?: string,
    resourceTypes?: Array<string>,
    options?: AxiosRequestConfig
  ) {
    return RealmsAdminApiFp(this.configuration)
      .realmAdminEventsGet(
        realm,
        authClient,
        authIpAddress,
        authRealm,
        authUser,
        dateFrom,
        dateTo,
        first,
        max,
        operationTypes,
        resourcePath,
        resourceTypes,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Base path for importing clients under this realm.
   * @param {string} realm realm name (not id!)
   * @param {string} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealmsAdminApi
   */
  public realmClientDescriptionConverterPost(
    realm: string,
    body: string,
    options?: AxiosRequestConfig
  ) {
    return RealmsAdminApiFp(this.configuration)
      .realmClientDescriptionConverterPost(realm, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} realm realm name (not id!)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealmsAdminApi
   */
  public realmClientPoliciesPoliciesGet(
    realm: string,
    options?: AxiosRequestConfig
  ) {
    return RealmsAdminApiFp(this.configuration)
      .realmClientPoliciesPoliciesGet(realm, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} realm realm name (not id!)
   * @param {ClientPoliciesRepresentation} clientPoliciesRepresentation
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealmsAdminApi
   */
  public realmClientPoliciesPoliciesPut(
    realm: string,
    clientPoliciesRepresentation: ClientPoliciesRepresentation,
    options?: AxiosRequestConfig
  ) {
    return RealmsAdminApiFp(this.configuration)
      .realmClientPoliciesPoliciesPut(
        realm,
        clientPoliciesRepresentation,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} realm realm name (not id!)
   * @param {boolean} [includeGlobalProfiles]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealmsAdminApi
   */
  public realmClientPoliciesProfilesGet(
    realm: string,
    includeGlobalProfiles?: boolean,
    options?: AxiosRequestConfig
  ) {
    return RealmsAdminApiFp(this.configuration)
      .realmClientPoliciesProfilesGet(realm, includeGlobalProfiles, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} realm realm name (not id!)
   * @param {ClientProfilesRepresentation} clientProfilesRepresentation
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealmsAdminApi
   */
  public realmClientPoliciesProfilesPut(
    realm: string,
    clientProfilesRepresentation: ClientProfilesRepresentation,
    options?: AxiosRequestConfig
  ) {
    return RealmsAdminApiFp(this.configuration)
      .realmClientPoliciesProfilesPut(
        realm,
        clientProfilesRepresentation,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get client session stats   Returns a JSON map.
   * @param {string} realm realm name (not id!)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealmsAdminApi
   */
  public realmClientSessionStatsGet(
    realm: string,
    options?: AxiosRequestConfig
  ) {
    return RealmsAdminApiFp(this.configuration)
      .realmClientSessionStatsGet(realm, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} realm realm name (not id!)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealmsAdminApi
   */
  public realmCredentialRegistratorsGet(
    realm: string,
    options?: AxiosRequestConfig
  ) {
    return RealmsAdminApiFp(this.configuration)
      .realmCredentialRegistratorsGet(realm, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} realm realm name (not id!)
   * @param {string} clientScopeId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealmsAdminApi
   */
  public realmDefaultDefaultClientScopesClientScopeIdDelete(
    realm: string,
    clientScopeId: string,
    options?: AxiosRequestConfig
  ) {
    return RealmsAdminApiFp(this.configuration)
      .realmDefaultDefaultClientScopesClientScopeIdDelete(
        realm,
        clientScopeId,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} realm realm name (not id!)
   * @param {string} clientScopeId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealmsAdminApi
   */
  public realmDefaultDefaultClientScopesClientScopeIdPut(
    realm: string,
    clientScopeId: string,
    options?: AxiosRequestConfig
  ) {
    return RealmsAdminApiFp(this.configuration)
      .realmDefaultDefaultClientScopesClientScopeIdPut(
        realm,
        clientScopeId,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get realm default client scopes.
   * @param {string} realm realm name (not id!)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealmsAdminApi
   */
  public realmDefaultDefaultClientScopesGet(
    realm: string,
    options?: AxiosRequestConfig
  ) {
    return RealmsAdminApiFp(this.configuration)
      .realmDefaultDefaultClientScopesGet(realm, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get group hierarchy.
   * @param {string} realm realm name (not id!)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealmsAdminApi
   */
  public realmDefaultGroupsGet(realm: string, options?: AxiosRequestConfig) {
    return RealmsAdminApiFp(this.configuration)
      .realmDefaultGroupsGet(realm, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} realm realm name (not id!)
   * @param {string} groupId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealmsAdminApi
   */
  public realmDefaultGroupsGroupIdDelete(
    realm: string,
    groupId: string,
    options?: AxiosRequestConfig
  ) {
    return RealmsAdminApiFp(this.configuration)
      .realmDefaultGroupsGroupIdDelete(realm, groupId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} realm realm name (not id!)
   * @param {string} groupId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealmsAdminApi
   */
  public realmDefaultGroupsGroupIdPut(
    realm: string,
    groupId: string,
    options?: AxiosRequestConfig
  ) {
    return RealmsAdminApiFp(this.configuration)
      .realmDefaultGroupsGroupIdPut(realm, groupId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} realm realm name (not id!)
   * @param {string} clientScopeId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealmsAdminApi
   */
  public realmDefaultOptionalClientScopesClientScopeIdDelete(
    realm: string,
    clientScopeId: string,
    options?: AxiosRequestConfig
  ) {
    return RealmsAdminApiFp(this.configuration)
      .realmDefaultOptionalClientScopesClientScopeIdDelete(
        realm,
        clientScopeId,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} realm realm name (not id!)
   * @param {string} clientScopeId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealmsAdminApi
   */
  public realmDefaultOptionalClientScopesClientScopeIdPut(
    realm: string,
    clientScopeId: string,
    options?: AxiosRequestConfig
  ) {
    return RealmsAdminApiFp(this.configuration)
      .realmDefaultOptionalClientScopesClientScopeIdPut(
        realm,
        clientScopeId,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get realm optional client scopes.
   * @param {string} realm realm name (not id!)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealmsAdminApi
   */
  public realmDefaultOptionalClientScopesGet(
    realm: string,
    options?: AxiosRequestConfig
  ) {
    return RealmsAdminApiFp(this.configuration)
      .realmDefaultOptionalClientScopesGet(realm, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete the realm
   * @param {string} realm realm name (not id!)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealmsAdminApi
   */
  public realmDelete(realm: string, options?: AxiosRequestConfig) {
    return RealmsAdminApiFp(this.configuration)
      .realmDelete(realm, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get the events provider configuration   Returns JSON object with events provider configuration
   * @param {string} realm realm name (not id!)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealmsAdminApi
   */
  public realmEventsConfigGet(realm: string, options?: AxiosRequestConfig) {
    return RealmsAdminApiFp(this.configuration)
      .realmEventsConfigGet(realm, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update the events provider   Change the events provider and/or its configuration
   * @param {string} realm realm name (not id!)
   * @param {RealmEventsConfigRepresentation} realmEventsConfigRepresentation
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealmsAdminApi
   */
  public realmEventsConfigPut(
    realm: string,
    realmEventsConfigRepresentation: RealmEventsConfigRepresentation,
    options?: AxiosRequestConfig
  ) {
    return RealmsAdminApiFp(this.configuration)
      .realmEventsConfigPut(realm, realmEventsConfigRepresentation, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete all events
   * @param {string} realm realm name (not id!)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealmsAdminApi
   */
  public realmEventsDelete(realm: string, options?: AxiosRequestConfig) {
    return RealmsAdminApiFp(this.configuration)
      .realmEventsDelete(realm, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get events   Returns all events, or filters them based on URL query parameters listed here
   * @param {string} realm realm name (not id!)
   * @param {string} [client] App or oauth client name
   * @param {string} [dateFrom] From date
   * @param {string} [dateTo] To date
   * @param {number} [first] Paging offset
   * @param {string} [ipAddress] IP address
   * @param {number} [max] Maximum results size (defaults to 100)
   * @param {Array<string>} [type] The types of events to return
   * @param {string} [user] User id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealmsAdminApi
   */
  public realmEventsGet(
    realm: string,
    client?: string,
    dateFrom?: string,
    dateTo?: string,
    first?: number,
    ipAddress?: string,
    max?: number,
    type?: Array<string>,
    user?: string,
    options?: AxiosRequestConfig
  ) {
    return RealmsAdminApiFp(this.configuration)
      .realmEventsGet(
        realm,
        client,
        dateFrom,
        dateTo,
        first,
        ipAddress,
        max,
        type,
        user,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get the top-level representation of the realm   It will not include nested information like User and Client representations.
   * @param {string} realm realm name (not id!)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealmsAdminApi
   */
  public realmGet(realm: string, options?: AxiosRequestConfig) {
    return RealmsAdminApiFp(this.configuration)
      .realmGet(realm, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} realm realm name (not id!)
   * @param {string} path
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealmsAdminApi
   */
  public realmGroupByPathPathGet(
    realm: string,
    path: string,
    options?: AxiosRequestConfig
  ) {
    return RealmsAdminApiFp(this.configuration)
      .realmGroupByPathPathGet(realm, path, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} realm realm name (not id!)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealmsAdminApi
   */
  public realmLocalizationGet(realm: string, options?: AxiosRequestConfig) {
    return RealmsAdminApiFp(this.configuration)
      .realmLocalizationGet(realm, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} realm realm name (not id!)
   * @param {string} locale
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealmsAdminApi
   */
  public realmLocalizationLocaleDelete(
    realm: string,
    locale: string,
    options?: AxiosRequestConfig
  ) {
    return RealmsAdminApiFp(this.configuration)
      .realmLocalizationLocaleDelete(realm, locale, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} realm realm name (not id!)
   * @param {string} locale
   * @param {boolean} [useRealmDefaultLocaleFallback]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealmsAdminApi
   */
  public realmLocalizationLocaleGet(
    realm: string,
    locale: string,
    useRealmDefaultLocaleFallback?: boolean,
    options?: AxiosRequestConfig
  ) {
    return RealmsAdminApiFp(this.configuration)
      .realmLocalizationLocaleGet(
        realm,
        locale,
        useRealmDefaultLocaleFallback,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} realm realm name (not id!)
   * @param {string} locale
   * @param {string} key
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealmsAdminApi
   */
  public realmLocalizationLocaleKeyDelete(
    realm: string,
    locale: string,
    key: string,
    options?: AxiosRequestConfig
  ) {
    return RealmsAdminApiFp(this.configuration)
      .realmLocalizationLocaleKeyDelete(realm, locale, key, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} realm realm name (not id!)
   * @param {string} locale
   * @param {string} key
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealmsAdminApi
   */
  public realmLocalizationLocaleKeyGet(
    realm: string,
    locale: string,
    key: string,
    options?: AxiosRequestConfig
  ) {
    return RealmsAdminApiFp(this.configuration)
      .realmLocalizationLocaleKeyGet(realm, locale, key, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} realm realm name (not id!)
   * @param {string} locale
   * @param {string} key
   * @param {string} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealmsAdminApi
   */
  public realmLocalizationLocaleKeyPut(
    realm: string,
    locale: string,
    key: string,
    body: string,
    options?: AxiosRequestConfig
  ) {
    return RealmsAdminApiFp(this.configuration)
      .realmLocalizationLocaleKeyPut(realm, locale, key, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} realm realm name (not id!)
   * @param {string} locale
   * @param {{ [key: string]: any; }} requestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealmsAdminApi
   */
  public realmLocalizationLocalePost(
    realm: string,
    locale: string,
    requestBody: { [key: string]: any },
    options?: AxiosRequestConfig
  ) {
    return RealmsAdminApiFp(this.configuration)
      .realmLocalizationLocalePost(realm, locale, requestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Removes all user sessions.
   * @param {string} realm realm name (not id!)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealmsAdminApi
   */
  public realmLogoutAllPost(realm: string, options?: AxiosRequestConfig) {
    return RealmsAdminApiFp(this.configuration)
      .realmLogoutAllPost(realm, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Partial export of existing realm into a JSON file.
   * @param {string} realm realm name (not id!)
   * @param {boolean} [exportClients]
   * @param {boolean} [exportGroupsAndRoles]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealmsAdminApi
   */
  public realmPartialExportPost(
    realm: string,
    exportClients?: boolean,
    exportGroupsAndRoles?: boolean,
    options?: AxiosRequestConfig
  ) {
    return RealmsAdminApiFp(this.configuration)
      .realmPartialExportPost(
        realm,
        exportClients,
        exportGroupsAndRoles,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Partial import from a JSON file to an existing realm.
   * @param {string} realm realm name (not id!)
   * @param {PartialImportRepresentation} partialImportRepresentation
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealmsAdminApi
   */
  public realmPartialImportPost(
    realm: string,
    partialImportRepresentation: PartialImportRepresentation,
    options?: AxiosRequestConfig
  ) {
    return RealmsAdminApiFp(this.configuration)
      .realmPartialImportPost(realm, partialImportRepresentation, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Push the realms revocation policy to any client that has an admin url associated with it.
   * @param {string} realm realm name (not id!)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealmsAdminApi
   */
  public realmPushRevocationPost(realm: string, options?: AxiosRequestConfig) {
    return RealmsAdminApiFp(this.configuration)
      .realmPushRevocationPost(realm, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update the top-level information of the realm   Any user, roles or client information in the representation  will be ignored.
   * @param {string} realm realm name (not id!)
   * @param {RealmRepresentation} realmRepresentation
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealmsAdminApi
   */
  public realmPut(
    realm: string,
    realmRepresentation: RealmRepresentation,
    options?: AxiosRequestConfig
  ) {
    return RealmsAdminApiFp(this.configuration)
      .realmPut(realm, realmRepresentation, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Remove a specific user session.
   * @param {string} realm realm name (not id!)
   * @param {string} session
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealmsAdminApi
   */
  public realmSessionsSessionDelete(
    realm: string,
    session: string,
    options?: AxiosRequestConfig
  ) {
    return RealmsAdminApiFp(this.configuration)
      .realmSessionsSessionDelete(realm, session, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} realm realm name (not id!)
   * @param {{ [key: string]: any; }} requestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealmsAdminApi
   */
  public realmTestSMTPConnectionPost(
    realm: string,
    requestBody: { [key: string]: any },
    options?: AxiosRequestConfig
  ) {
    return RealmsAdminApiFp(this.configuration)
      .realmTestSMTPConnectionPost(realm, requestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} realm realm name (not id!)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealmsAdminApi
   */
  public realmUsersManagementPermissionsGet(
    realm: string,
    options?: AxiosRequestConfig
  ) {
    return RealmsAdminApiFp(this.configuration)
      .realmUsersManagementPermissionsGet(realm, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} realm realm name (not id!)
   * @param {ManagementPermissionReference} managementPermissionReference
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealmsAdminApi
   */
  public realmUsersManagementPermissionsPut(
    realm: string,
    managementPermissionReference: ManagementPermissionReference,
    options?: AxiosRequestConfig
  ) {
    return RealmsAdminApiFp(this.configuration)
      .realmUsersManagementPermissionsPut(
        realm,
        managementPermissionReference,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Import a realm   Imports a realm from a full representation of that realm.
   * @param {RealmRepresentation} realmRepresentation JSON representation of the realm
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealmsAdminApi
   */
  public rootPost(
    realmRepresentation: RealmRepresentation,
    options?: AxiosRequestConfig
  ) {
    return RealmsAdminApiFp(this.configuration)
      .rootPost(realmRepresentation, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
