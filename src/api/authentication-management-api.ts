/* tslint:disable */
/* eslint-disable */
/**
 * Keycloak Admin REST API
 * This is a REST API reference for the Keycloak Admin REST API.
 *
 * The version of the OpenAPI document: 1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from '../common';
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from '../base';
// @ts-ignore
import { AuthenticationExecutionInfoRepresentation } from '../model';
// @ts-ignore
import { AuthenticationExecutionRepresentation } from '../model';
// @ts-ignore
import { AuthenticationFlowRepresentation } from '../model';
// @ts-ignore
import { AuthenticatorConfigInfoRepresentation } from '../model';
// @ts-ignore
import { AuthenticatorConfigRepresentation } from '../model';
// @ts-ignore
import { RequiredActionProviderRepresentation } from '../model';
/**
 * AuthenticationManagementApi - axios parameter creator
 * @export
 */
export const AuthenticationManagementApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Get authenticator providers   Returns a stream of authenticator providers.
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationAuthenticatorProvidersGet: async (
      realm: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmAuthenticationAuthenticatorProvidersGet',
        'realm',
        realm
      );
      const localVarPath =
        `/{realm}/authentication/authenticator-providers`.replace(
          `{${'realm'}}`,
          encodeURIComponent(String(realm))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get client authenticator providers   Returns a stream of client authenticator providers.
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationClientAuthenticatorProvidersGet: async (
      realm: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmAuthenticationClientAuthenticatorProvidersGet',
        'realm',
        realm
      );
      const localVarPath =
        `/{realm}/authentication/client-authenticator-providers`.replace(
          `{${'realm'}}`,
          encodeURIComponent(String(realm))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get authenticator provider’s configuration description
     * @param {string} realm realm name (not id!)
     * @param {string} providerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationConfigDescriptionProviderIdGet: async (
      realm: string,
      providerId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmAuthenticationConfigDescriptionProviderIdGet',
        'realm',
        realm
      );
      // verify required parameter 'providerId' is not null or undefined
      assertParamExists(
        'realmAuthenticationConfigDescriptionProviderIdGet',
        'providerId',
        providerId
      );
      const localVarPath =
        `/{realm}/authentication/config-description/{providerId}`
          .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
          .replace(`{${'providerId'}}`, encodeURIComponent(String(providerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete authenticator configuration
     * @param {string} realm realm name (not id!)
     * @param {string} id Configuration id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationConfigIdDelete: async (
      realm: string,
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmAuthenticationConfigIdDelete', 'realm', realm);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmAuthenticationConfigIdDelete', 'id', id);
      const localVarPath = `/{realm}/authentication/config/{id}`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get authenticator configuration
     * @param {string} realm realm name (not id!)
     * @param {string} id Configuration id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationConfigIdGet: async (
      realm: string,
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmAuthenticationConfigIdGet', 'realm', realm);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmAuthenticationConfigIdGet', 'id', id);
      const localVarPath = `/{realm}/authentication/config/{id}`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update authenticator configuration
     * @param {string} realm realm name (not id!)
     * @param {string} id Configuration id
     * @param {AuthenticatorConfigRepresentation} authenticatorConfigRepresentation JSON describing new state of authenticator configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationConfigIdPut: async (
      realm: string,
      id: string,
      authenticatorConfigRepresentation: AuthenticatorConfigRepresentation,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmAuthenticationConfigIdPut', 'realm', realm);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmAuthenticationConfigIdPut', 'id', id);
      // verify required parameter 'authenticatorConfigRepresentation' is not null or undefined
      assertParamExists(
        'realmAuthenticationConfigIdPut',
        'authenticatorConfigRepresentation',
        authenticatorConfigRepresentation
      );
      const localVarPath = `/{realm}/authentication/config/{id}`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        authenticatorConfigRepresentation,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update execution with new configuration
     * @param {string} realm realm name (not id!)
     * @param {string} executionId Execution id
     * @param {AuthenticatorConfigRepresentation} authenticatorConfigRepresentation JSON with new configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationExecutionsExecutionIdConfigPost: async (
      realm: string,
      executionId: string,
      authenticatorConfigRepresentation: AuthenticatorConfigRepresentation,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmAuthenticationExecutionsExecutionIdConfigPost',
        'realm',
        realm
      );
      // verify required parameter 'executionId' is not null or undefined
      assertParamExists(
        'realmAuthenticationExecutionsExecutionIdConfigPost',
        'executionId',
        executionId
      );
      // verify required parameter 'authenticatorConfigRepresentation' is not null or undefined
      assertParamExists(
        'realmAuthenticationExecutionsExecutionIdConfigPost',
        'authenticatorConfigRepresentation',
        authenticatorConfigRepresentation
      );
      const localVarPath =
        `/{realm}/authentication/executions/{executionId}/config`
          .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
          .replace(
            `{${'executionId'}}`,
            encodeURIComponent(String(executionId))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        authenticatorConfigRepresentation,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete execution
     * @param {string} realm realm name (not id!)
     * @param {string} executionId Execution id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationExecutionsExecutionIdDelete: async (
      realm: string,
      executionId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmAuthenticationExecutionsExecutionIdDelete',
        'realm',
        realm
      );
      // verify required parameter 'executionId' is not null or undefined
      assertParamExists(
        'realmAuthenticationExecutionsExecutionIdDelete',
        'executionId',
        executionId
      );
      const localVarPath = `/{realm}/authentication/executions/{executionId}`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'executionId'}}`, encodeURIComponent(String(executionId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Single Execution
     * @param {string} realm realm name (not id!)
     * @param {string} executionId Execution id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationExecutionsExecutionIdGet: async (
      realm: string,
      executionId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmAuthenticationExecutionsExecutionIdGet',
        'realm',
        realm
      );
      // verify required parameter 'executionId' is not null or undefined
      assertParamExists(
        'realmAuthenticationExecutionsExecutionIdGet',
        'executionId',
        executionId
      );
      const localVarPath = `/{realm}/authentication/executions/{executionId}`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'executionId'}}`, encodeURIComponent(String(executionId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Lower execution’s priority
     * @param {string} realm realm name (not id!)
     * @param {string} executionId Execution id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationExecutionsExecutionIdLowerPriorityPost: async (
      realm: string,
      executionId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmAuthenticationExecutionsExecutionIdLowerPriorityPost',
        'realm',
        realm
      );
      // verify required parameter 'executionId' is not null or undefined
      assertParamExists(
        'realmAuthenticationExecutionsExecutionIdLowerPriorityPost',
        'executionId',
        executionId
      );
      const localVarPath =
        `/{realm}/authentication/executions/{executionId}/lower-priority`
          .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
          .replace(
            `{${'executionId'}}`,
            encodeURIComponent(String(executionId))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Raise execution’s priority
     * @param {string} realm realm name (not id!)
     * @param {string} executionId Execution id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationExecutionsExecutionIdRaisePriorityPost: async (
      realm: string,
      executionId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmAuthenticationExecutionsExecutionIdRaisePriorityPost',
        'realm',
        realm
      );
      // verify required parameter 'executionId' is not null or undefined
      assertParamExists(
        'realmAuthenticationExecutionsExecutionIdRaisePriorityPost',
        'executionId',
        executionId
      );
      const localVarPath =
        `/{realm}/authentication/executions/{executionId}/raise-priority`
          .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
          .replace(
            `{${'executionId'}}`,
            encodeURIComponent(String(executionId))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Add new authentication execution
     * @param {string} realm realm name (not id!)
     * @param {AuthenticationExecutionRepresentation} authenticationExecutionRepresentation JSON model describing authentication execution
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationExecutionsPost: async (
      realm: string,
      authenticationExecutionRepresentation: AuthenticationExecutionRepresentation,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmAuthenticationExecutionsPost', 'realm', realm);
      // verify required parameter 'authenticationExecutionRepresentation' is not null or undefined
      assertParamExists(
        'realmAuthenticationExecutionsPost',
        'authenticationExecutionRepresentation',
        authenticationExecutionRepresentation
      );
      const localVarPath = `/{realm}/authentication/executions`.replace(
        `{${'realm'}}`,
        encodeURIComponent(String(realm))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        authenticationExecutionRepresentation,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Copy existing authentication flow under a new name   The new name is given as \'newName\' attribute of the passed JSON object
     * @param {string} realm realm name (not id!)
     * @param {string} flowAlias Name of the existing authentication flow
     * @param {{ [key: string]: any; }} requestBody JSON containing \&#39;newName\&#39; attribute
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationFlowsFlowAliasCopyPost: async (
      realm: string,
      flowAlias: string,
      requestBody: { [key: string]: any },
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmAuthenticationFlowsFlowAliasCopyPost',
        'realm',
        realm
      );
      // verify required parameter 'flowAlias' is not null or undefined
      assertParamExists(
        'realmAuthenticationFlowsFlowAliasCopyPost',
        'flowAlias',
        flowAlias
      );
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists(
        'realmAuthenticationFlowsFlowAliasCopyPost',
        'requestBody',
        requestBody
      );
      const localVarPath = `/{realm}/authentication/flows/{flowAlias}/copy`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'flowAlias'}}`, encodeURIComponent(String(flowAlias)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Add new authentication execution to a flow
     * @param {string} realm realm name (not id!)
     * @param {string} flowAlias Alias of parent flow
     * @param {{ [key: string]: any; }} requestBody New execution JSON data containing \&#39;provider\&#39; attribute
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationFlowsFlowAliasExecutionsExecutionPost: async (
      realm: string,
      flowAlias: string,
      requestBody: { [key: string]: any },
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmAuthenticationFlowsFlowAliasExecutionsExecutionPost',
        'realm',
        realm
      );
      // verify required parameter 'flowAlias' is not null or undefined
      assertParamExists(
        'realmAuthenticationFlowsFlowAliasExecutionsExecutionPost',
        'flowAlias',
        flowAlias
      );
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists(
        'realmAuthenticationFlowsFlowAliasExecutionsExecutionPost',
        'requestBody',
        requestBody
      );
      const localVarPath =
        `/{realm}/authentication/flows/{flowAlias}/executions/execution`
          .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
          .replace(`{${'flowAlias'}}`, encodeURIComponent(String(flowAlias)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Add new flow with new execution to existing flow
     * @param {string} realm realm name (not id!)
     * @param {string} flowAlias Alias of parent authentication flow
     * @param {{ [key: string]: any; }} requestBody New authentication flow / execution JSON data containing \&#39;alias\&#39;, \&#39;type\&#39;, \&#39;provider\&#39;, and \&#39;description\&#39; attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationFlowsFlowAliasExecutionsFlowPost: async (
      realm: string,
      flowAlias: string,
      requestBody: { [key: string]: any },
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmAuthenticationFlowsFlowAliasExecutionsFlowPost',
        'realm',
        realm
      );
      // verify required parameter 'flowAlias' is not null or undefined
      assertParamExists(
        'realmAuthenticationFlowsFlowAliasExecutionsFlowPost',
        'flowAlias',
        flowAlias
      );
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists(
        'realmAuthenticationFlowsFlowAliasExecutionsFlowPost',
        'requestBody',
        requestBody
      );
      const localVarPath =
        `/{realm}/authentication/flows/{flowAlias}/executions/flow`
          .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
          .replace(`{${'flowAlias'}}`, encodeURIComponent(String(flowAlias)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get authentication executions for a flow
     * @param {string} realm realm name (not id!)
     * @param {string} flowAlias Flow alias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationFlowsFlowAliasExecutionsGet: async (
      realm: string,
      flowAlias: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmAuthenticationFlowsFlowAliasExecutionsGet',
        'realm',
        realm
      );
      // verify required parameter 'flowAlias' is not null or undefined
      assertParamExists(
        'realmAuthenticationFlowsFlowAliasExecutionsGet',
        'flowAlias',
        flowAlias
      );
      const localVarPath =
        `/{realm}/authentication/flows/{flowAlias}/executions`
          .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
          .replace(`{${'flowAlias'}}`, encodeURIComponent(String(flowAlias)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update authentication executions of a Flow
     * @param {string} realm realm name (not id!)
     * @param {string} flowAlias Flow alias
     * @param {AuthenticationExecutionInfoRepresentation} authenticationExecutionInfoRepresentation AuthenticationExecutionInfoRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationFlowsFlowAliasExecutionsPut: async (
      realm: string,
      flowAlias: string,
      authenticationExecutionInfoRepresentation: AuthenticationExecutionInfoRepresentation,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmAuthenticationFlowsFlowAliasExecutionsPut',
        'realm',
        realm
      );
      // verify required parameter 'flowAlias' is not null or undefined
      assertParamExists(
        'realmAuthenticationFlowsFlowAliasExecutionsPut',
        'flowAlias',
        flowAlias
      );
      // verify required parameter 'authenticationExecutionInfoRepresentation' is not null or undefined
      assertParamExists(
        'realmAuthenticationFlowsFlowAliasExecutionsPut',
        'authenticationExecutionInfoRepresentation',
        authenticationExecutionInfoRepresentation
      );
      const localVarPath =
        `/{realm}/authentication/flows/{flowAlias}/executions`
          .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
          .replace(`{${'flowAlias'}}`, encodeURIComponent(String(flowAlias)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        authenticationExecutionInfoRepresentation,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get authentication flows   Returns a stream of authentication flows.
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationFlowsGet: async (
      realm: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmAuthenticationFlowsGet', 'realm', realm);
      const localVarPath = `/{realm}/authentication/flows`.replace(
        `{${'realm'}}`,
        encodeURIComponent(String(realm))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete an authentication flow
     * @param {string} realm realm name (not id!)
     * @param {string} id Flow id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationFlowsIdDelete: async (
      realm: string,
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmAuthenticationFlowsIdDelete', 'realm', realm);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmAuthenticationFlowsIdDelete', 'id', id);
      const localVarPath = `/{realm}/authentication/flows/{id}`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get authentication flow for id
     * @param {string} realm realm name (not id!)
     * @param {string} id Flow id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationFlowsIdGet: async (
      realm: string,
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmAuthenticationFlowsIdGet', 'realm', realm);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmAuthenticationFlowsIdGet', 'id', id);
      const localVarPath = `/{realm}/authentication/flows/{id}`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update an authentication flow
     * @param {string} realm realm name (not id!)
     * @param {string} id Flow id
     * @param {AuthenticationFlowRepresentation} authenticationFlowRepresentation Authentication flow representation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationFlowsIdPut: async (
      realm: string,
      id: string,
      authenticationFlowRepresentation: AuthenticationFlowRepresentation,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmAuthenticationFlowsIdPut', 'realm', realm);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmAuthenticationFlowsIdPut', 'id', id);
      // verify required parameter 'authenticationFlowRepresentation' is not null or undefined
      assertParamExists(
        'realmAuthenticationFlowsIdPut',
        'authenticationFlowRepresentation',
        authenticationFlowRepresentation
      );
      const localVarPath = `/{realm}/authentication/flows/{id}`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        authenticationFlowRepresentation,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create a new authentication flow
     * @param {string} realm realm name (not id!)
     * @param {AuthenticationFlowRepresentation} authenticationFlowRepresentation Authentication flow representation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationFlowsPost: async (
      realm: string,
      authenticationFlowRepresentation: AuthenticationFlowRepresentation,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmAuthenticationFlowsPost', 'realm', realm);
      // verify required parameter 'authenticationFlowRepresentation' is not null or undefined
      assertParamExists(
        'realmAuthenticationFlowsPost',
        'authenticationFlowRepresentation',
        authenticationFlowRepresentation
      );
      const localVarPath = `/{realm}/authentication/flows`.replace(
        `{${'realm'}}`,
        encodeURIComponent(String(realm))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        authenticationFlowRepresentation,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get form action providers   Returns a stream of form action providers.
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationFormActionProvidersGet: async (
      realm: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmAuthenticationFormActionProvidersGet',
        'realm',
        realm
      );
      const localVarPath =
        `/{realm}/authentication/form-action-providers`.replace(
          `{${'realm'}}`,
          encodeURIComponent(String(realm))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get form providers   Returns a stream of form providers.
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationFormProvidersGet: async (
      realm: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmAuthenticationFormProvidersGet', 'realm', realm);
      const localVarPath = `/{realm}/authentication/form-providers`.replace(
        `{${'realm'}}`,
        encodeURIComponent(String(realm))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get configuration descriptions for all clients
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationPerClientConfigDescriptionGet: async (
      realm: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmAuthenticationPerClientConfigDescriptionGet',
        'realm',
        realm
      );
      const localVarPath =
        `/{realm}/authentication/per-client-config-description`.replace(
          `{${'realm'}}`,
          encodeURIComponent(String(realm))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Register a new required actions
     * @param {string} realm realm name (not id!)
     * @param {{ [key: string]: any; }} requestBody JSON containing \&#39;providerId\&#39;, and \&#39;name\&#39; attributes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationRegisterRequiredActionPost: async (
      realm: string,
      requestBody: { [key: string]: any },
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmAuthenticationRegisterRequiredActionPost',
        'realm',
        realm
      );
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists(
        'realmAuthenticationRegisterRequiredActionPost',
        'requestBody',
        requestBody
      );
      const localVarPath =
        `/{realm}/authentication/register-required-action`.replace(
          `{${'realm'}}`,
          encodeURIComponent(String(realm))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete required action
     * @param {string} realm realm name (not id!)
     * @param {string} alias Alias of required action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationRequiredActionsAliasDelete: async (
      realm: string,
      alias: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmAuthenticationRequiredActionsAliasDelete',
        'realm',
        realm
      );
      // verify required parameter 'alias' is not null or undefined
      assertParamExists(
        'realmAuthenticationRequiredActionsAliasDelete',
        'alias',
        alias
      );
      const localVarPath = `/{realm}/authentication/required-actions/{alias}`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'alias'}}`, encodeURIComponent(String(alias)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get required action for alias
     * @param {string} realm realm name (not id!)
     * @param {string} alias Alias of required action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationRequiredActionsAliasGet: async (
      realm: string,
      alias: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmAuthenticationRequiredActionsAliasGet',
        'realm',
        realm
      );
      // verify required parameter 'alias' is not null or undefined
      assertParamExists(
        'realmAuthenticationRequiredActionsAliasGet',
        'alias',
        alias
      );
      const localVarPath = `/{realm}/authentication/required-actions/{alias}`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'alias'}}`, encodeURIComponent(String(alias)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Lower required action’s priority
     * @param {string} realm realm name (not id!)
     * @param {string} alias Alias of required action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationRequiredActionsAliasLowerPriorityPost: async (
      realm: string,
      alias: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmAuthenticationRequiredActionsAliasLowerPriorityPost',
        'realm',
        realm
      );
      // verify required parameter 'alias' is not null or undefined
      assertParamExists(
        'realmAuthenticationRequiredActionsAliasLowerPriorityPost',
        'alias',
        alias
      );
      const localVarPath =
        `/{realm}/authentication/required-actions/{alias}/lower-priority`
          .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
          .replace(`{${'alias'}}`, encodeURIComponent(String(alias)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update required action
     * @param {string} realm realm name (not id!)
     * @param {string} alias Alias of required action
     * @param {RequiredActionProviderRepresentation} requiredActionProviderRepresentation JSON describing new state of required action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationRequiredActionsAliasPut: async (
      realm: string,
      alias: string,
      requiredActionProviderRepresentation: RequiredActionProviderRepresentation,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmAuthenticationRequiredActionsAliasPut',
        'realm',
        realm
      );
      // verify required parameter 'alias' is not null or undefined
      assertParamExists(
        'realmAuthenticationRequiredActionsAliasPut',
        'alias',
        alias
      );
      // verify required parameter 'requiredActionProviderRepresentation' is not null or undefined
      assertParamExists(
        'realmAuthenticationRequiredActionsAliasPut',
        'requiredActionProviderRepresentation',
        requiredActionProviderRepresentation
      );
      const localVarPath = `/{realm}/authentication/required-actions/{alias}`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'alias'}}`, encodeURIComponent(String(alias)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requiredActionProviderRepresentation,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Raise required action’s priority
     * @param {string} realm realm name (not id!)
     * @param {string} alias Alias of required action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationRequiredActionsAliasRaisePriorityPost: async (
      realm: string,
      alias: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmAuthenticationRequiredActionsAliasRaisePriorityPost',
        'realm',
        realm
      );
      // verify required parameter 'alias' is not null or undefined
      assertParamExists(
        'realmAuthenticationRequiredActionsAliasRaisePriorityPost',
        'alias',
        alias
      );
      const localVarPath =
        `/{realm}/authentication/required-actions/{alias}/raise-priority`
          .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
          .replace(`{${'alias'}}`, encodeURIComponent(String(alias)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get required actions   Returns a stream of required actions.
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationRequiredActionsGet: async (
      realm: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmAuthenticationRequiredActionsGet',
        'realm',
        realm
      );
      const localVarPath = `/{realm}/authentication/required-actions`.replace(
        `{${'realm'}}`,
        encodeURIComponent(String(realm))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get unregistered required actions   Returns a stream of unregistered required actions.
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationUnregisteredRequiredActionsGet: async (
      realm: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmAuthenticationUnregisteredRequiredActionsGet',
        'realm',
        realm
      );
      const localVarPath =
        `/{realm}/authentication/unregistered-required-actions`.replace(
          `{${'realm'}}`,
          encodeURIComponent(String(realm))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AuthenticationManagementApi - functional programming interface
 * @export
 */
export const AuthenticationManagementApiFp = function (
  configuration?: Configuration
) {
  const localVarAxiosParamCreator =
    AuthenticationManagementApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Get authenticator providers   Returns a stream of authenticator providers.
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmAuthenticationAuthenticatorProvidersGet(
      realm: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<{ [key: string]: any }>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmAuthenticationAuthenticatorProvidersGet(
          realm,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get client authenticator providers   Returns a stream of client authenticator providers.
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmAuthenticationClientAuthenticatorProvidersGet(
      realm: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<{ [key: string]: any }>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmAuthenticationClientAuthenticatorProvidersGet(
          realm,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get authenticator provider’s configuration description
     * @param {string} realm realm name (not id!)
     * @param {string} providerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmAuthenticationConfigDescriptionProviderIdGet(
      realm: string,
      providerId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AuthenticatorConfigInfoRepresentation>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmAuthenticationConfigDescriptionProviderIdGet(
          realm,
          providerId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Delete authenticator configuration
     * @param {string} realm realm name (not id!)
     * @param {string} id Configuration id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmAuthenticationConfigIdDelete(
      realm: string,
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmAuthenticationConfigIdDelete(
          realm,
          id,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get authenticator configuration
     * @param {string} realm realm name (not id!)
     * @param {string} id Configuration id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmAuthenticationConfigIdGet(
      realm: string,
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AuthenticatorConfigRepresentation>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmAuthenticationConfigIdGet(
          realm,
          id,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Update authenticator configuration
     * @param {string} realm realm name (not id!)
     * @param {string} id Configuration id
     * @param {AuthenticatorConfigRepresentation} authenticatorConfigRepresentation JSON describing new state of authenticator configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmAuthenticationConfigIdPut(
      realm: string,
      id: string,
      authenticatorConfigRepresentation: AuthenticatorConfigRepresentation,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmAuthenticationConfigIdPut(
          realm,
          id,
          authenticatorConfigRepresentation,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Update execution with new configuration
     * @param {string} realm realm name (not id!)
     * @param {string} executionId Execution id
     * @param {AuthenticatorConfigRepresentation} authenticatorConfigRepresentation JSON with new configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmAuthenticationExecutionsExecutionIdConfigPost(
      realm: string,
      executionId: string,
      authenticatorConfigRepresentation: AuthenticatorConfigRepresentation,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmAuthenticationExecutionsExecutionIdConfigPost(
          realm,
          executionId,
          authenticatorConfigRepresentation,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Delete execution
     * @param {string} realm realm name (not id!)
     * @param {string} executionId Execution id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmAuthenticationExecutionsExecutionIdDelete(
      realm: string,
      executionId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmAuthenticationExecutionsExecutionIdDelete(
          realm,
          executionId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get Single Execution
     * @param {string} realm realm name (not id!)
     * @param {string} executionId Execution id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmAuthenticationExecutionsExecutionIdGet(
      realm: string,
      executionId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmAuthenticationExecutionsExecutionIdGet(
          realm,
          executionId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Lower execution’s priority
     * @param {string} realm realm name (not id!)
     * @param {string} executionId Execution id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmAuthenticationExecutionsExecutionIdLowerPriorityPost(
      realm: string,
      executionId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmAuthenticationExecutionsExecutionIdLowerPriorityPost(
          realm,
          executionId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Raise execution’s priority
     * @param {string} realm realm name (not id!)
     * @param {string} executionId Execution id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmAuthenticationExecutionsExecutionIdRaisePriorityPost(
      realm: string,
      executionId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmAuthenticationExecutionsExecutionIdRaisePriorityPost(
          realm,
          executionId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Add new authentication execution
     * @param {string} realm realm name (not id!)
     * @param {AuthenticationExecutionRepresentation} authenticationExecutionRepresentation JSON model describing authentication execution
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmAuthenticationExecutionsPost(
      realm: string,
      authenticationExecutionRepresentation: AuthenticationExecutionRepresentation,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmAuthenticationExecutionsPost(
          realm,
          authenticationExecutionRepresentation,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Copy existing authentication flow under a new name   The new name is given as \'newName\' attribute of the passed JSON object
     * @param {string} realm realm name (not id!)
     * @param {string} flowAlias Name of the existing authentication flow
     * @param {{ [key: string]: any; }} requestBody JSON containing \&#39;newName\&#39; attribute
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmAuthenticationFlowsFlowAliasCopyPost(
      realm: string,
      flowAlias: string,
      requestBody: { [key: string]: any },
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmAuthenticationFlowsFlowAliasCopyPost(
          realm,
          flowAlias,
          requestBody,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Add new authentication execution to a flow
     * @param {string} realm realm name (not id!)
     * @param {string} flowAlias Alias of parent flow
     * @param {{ [key: string]: any; }} requestBody New execution JSON data containing \&#39;provider\&#39; attribute
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmAuthenticationFlowsFlowAliasExecutionsExecutionPost(
      realm: string,
      flowAlias: string,
      requestBody: { [key: string]: any },
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmAuthenticationFlowsFlowAliasExecutionsExecutionPost(
          realm,
          flowAlias,
          requestBody,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Add new flow with new execution to existing flow
     * @param {string} realm realm name (not id!)
     * @param {string} flowAlias Alias of parent authentication flow
     * @param {{ [key: string]: any; }} requestBody New authentication flow / execution JSON data containing \&#39;alias\&#39;, \&#39;type\&#39;, \&#39;provider\&#39;, and \&#39;description\&#39; attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmAuthenticationFlowsFlowAliasExecutionsFlowPost(
      realm: string,
      flowAlias: string,
      requestBody: { [key: string]: any },
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmAuthenticationFlowsFlowAliasExecutionsFlowPost(
          realm,
          flowAlias,
          requestBody,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get authentication executions for a flow
     * @param {string} realm realm name (not id!)
     * @param {string} flowAlias Flow alias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmAuthenticationFlowsFlowAliasExecutionsGet(
      realm: string,
      flowAlias: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmAuthenticationFlowsFlowAliasExecutionsGet(
          realm,
          flowAlias,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Update authentication executions of a Flow
     * @param {string} realm realm name (not id!)
     * @param {string} flowAlias Flow alias
     * @param {AuthenticationExecutionInfoRepresentation} authenticationExecutionInfoRepresentation AuthenticationExecutionInfoRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmAuthenticationFlowsFlowAliasExecutionsPut(
      realm: string,
      flowAlias: string,
      authenticationExecutionInfoRepresentation: AuthenticationExecutionInfoRepresentation,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmAuthenticationFlowsFlowAliasExecutionsPut(
          realm,
          flowAlias,
          authenticationExecutionInfoRepresentation,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get authentication flows   Returns a stream of authentication flows.
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmAuthenticationFlowsGet(
      realm: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<{ [key: string]: any }>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmAuthenticationFlowsGet(
          realm,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Delete an authentication flow
     * @param {string} realm realm name (not id!)
     * @param {string} id Flow id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmAuthenticationFlowsIdDelete(
      realm: string,
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmAuthenticationFlowsIdDelete(
          realm,
          id,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get authentication flow for id
     * @param {string} realm realm name (not id!)
     * @param {string} id Flow id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmAuthenticationFlowsIdGet(
      realm: string,
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AuthenticationFlowRepresentation>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmAuthenticationFlowsIdGet(
          realm,
          id,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Update an authentication flow
     * @param {string} realm realm name (not id!)
     * @param {string} id Flow id
     * @param {AuthenticationFlowRepresentation} authenticationFlowRepresentation Authentication flow representation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmAuthenticationFlowsIdPut(
      realm: string,
      id: string,
      authenticationFlowRepresentation: AuthenticationFlowRepresentation,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmAuthenticationFlowsIdPut(
          realm,
          id,
          authenticationFlowRepresentation,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Create a new authentication flow
     * @param {string} realm realm name (not id!)
     * @param {AuthenticationFlowRepresentation} authenticationFlowRepresentation Authentication flow representation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmAuthenticationFlowsPost(
      realm: string,
      authenticationFlowRepresentation: AuthenticationFlowRepresentation,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmAuthenticationFlowsPost(
          realm,
          authenticationFlowRepresentation,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get form action providers   Returns a stream of form action providers.
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmAuthenticationFormActionProvidersGet(
      realm: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<{ [key: string]: any }>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmAuthenticationFormActionProvidersGet(
          realm,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get form providers   Returns a stream of form providers.
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmAuthenticationFormProvidersGet(
      realm: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<{ [key: string]: any }>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmAuthenticationFormProvidersGet(
          realm,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get configuration descriptions for all clients
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmAuthenticationPerClientConfigDescriptionGet(
      realm: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: any }>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmAuthenticationPerClientConfigDescriptionGet(
          realm,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Register a new required actions
     * @param {string} realm realm name (not id!)
     * @param {{ [key: string]: any; }} requestBody JSON containing \&#39;providerId\&#39;, and \&#39;name\&#39; attributes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmAuthenticationRegisterRequiredActionPost(
      realm: string,
      requestBody: { [key: string]: any },
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmAuthenticationRegisterRequiredActionPost(
          realm,
          requestBody,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Delete required action
     * @param {string} realm realm name (not id!)
     * @param {string} alias Alias of required action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmAuthenticationRequiredActionsAliasDelete(
      realm: string,
      alias: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmAuthenticationRequiredActionsAliasDelete(
          realm,
          alias,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get required action for alias
     * @param {string} realm realm name (not id!)
     * @param {string} alias Alias of required action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmAuthenticationRequiredActionsAliasGet(
      realm: string,
      alias: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<RequiredActionProviderRepresentation>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmAuthenticationRequiredActionsAliasGet(
          realm,
          alias,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Lower required action’s priority
     * @param {string} realm realm name (not id!)
     * @param {string} alias Alias of required action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmAuthenticationRequiredActionsAliasLowerPriorityPost(
      realm: string,
      alias: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmAuthenticationRequiredActionsAliasLowerPriorityPost(
          realm,
          alias,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Update required action
     * @param {string} realm realm name (not id!)
     * @param {string} alias Alias of required action
     * @param {RequiredActionProviderRepresentation} requiredActionProviderRepresentation JSON describing new state of required action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmAuthenticationRequiredActionsAliasPut(
      realm: string,
      alias: string,
      requiredActionProviderRepresentation: RequiredActionProviderRepresentation,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmAuthenticationRequiredActionsAliasPut(
          realm,
          alias,
          requiredActionProviderRepresentation,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Raise required action’s priority
     * @param {string} realm realm name (not id!)
     * @param {string} alias Alias of required action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmAuthenticationRequiredActionsAliasRaisePriorityPost(
      realm: string,
      alias: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmAuthenticationRequiredActionsAliasRaisePriorityPost(
          realm,
          alias,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get required actions   Returns a stream of required actions.
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmAuthenticationRequiredActionsGet(
      realm: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<{ [key: string]: any }>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmAuthenticationRequiredActionsGet(
          realm,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get unregistered required actions   Returns a stream of unregistered required actions.
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmAuthenticationUnregisteredRequiredActionsGet(
      realm: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<{ [key: string]: any }>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmAuthenticationUnregisteredRequiredActionsGet(
          realm,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * AuthenticationManagementApi - factory interface
 * @export
 */
export const AuthenticationManagementApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = AuthenticationManagementApiFp(configuration);
  return {
    /**
     *
     * @summary Get authenticator providers   Returns a stream of authenticator providers.
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationAuthenticatorProvidersGet(
      realm: string,
      options?: any
    ): AxiosPromise<Array<{ [key: string]: any }>> {
      return localVarFp
        .realmAuthenticationAuthenticatorProvidersGet(realm, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get client authenticator providers   Returns a stream of client authenticator providers.
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationClientAuthenticatorProvidersGet(
      realm: string,
      options?: any
    ): AxiosPromise<Array<{ [key: string]: any }>> {
      return localVarFp
        .realmAuthenticationClientAuthenticatorProvidersGet(realm, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get authenticator provider’s configuration description
     * @param {string} realm realm name (not id!)
     * @param {string} providerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationConfigDescriptionProviderIdGet(
      realm: string,
      providerId: string,
      options?: any
    ): AxiosPromise<AuthenticatorConfigInfoRepresentation> {
      return localVarFp
        .realmAuthenticationConfigDescriptionProviderIdGet(
          realm,
          providerId,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete authenticator configuration
     * @param {string} realm realm name (not id!)
     * @param {string} id Configuration id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationConfigIdDelete(
      realm: string,
      id: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmAuthenticationConfigIdDelete(realm, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get authenticator configuration
     * @param {string} realm realm name (not id!)
     * @param {string} id Configuration id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationConfigIdGet(
      realm: string,
      id: string,
      options?: any
    ): AxiosPromise<AuthenticatorConfigRepresentation> {
      return localVarFp
        .realmAuthenticationConfigIdGet(realm, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update authenticator configuration
     * @param {string} realm realm name (not id!)
     * @param {string} id Configuration id
     * @param {AuthenticatorConfigRepresentation} authenticatorConfigRepresentation JSON describing new state of authenticator configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationConfigIdPut(
      realm: string,
      id: string,
      authenticatorConfigRepresentation: AuthenticatorConfigRepresentation,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmAuthenticationConfigIdPut(
          realm,
          id,
          authenticatorConfigRepresentation,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update execution with new configuration
     * @param {string} realm realm name (not id!)
     * @param {string} executionId Execution id
     * @param {AuthenticatorConfigRepresentation} authenticatorConfigRepresentation JSON with new configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationExecutionsExecutionIdConfigPost(
      realm: string,
      executionId: string,
      authenticatorConfigRepresentation: AuthenticatorConfigRepresentation,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmAuthenticationExecutionsExecutionIdConfigPost(
          realm,
          executionId,
          authenticatorConfigRepresentation,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete execution
     * @param {string} realm realm name (not id!)
     * @param {string} executionId Execution id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationExecutionsExecutionIdDelete(
      realm: string,
      executionId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmAuthenticationExecutionsExecutionIdDelete(
          realm,
          executionId,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Single Execution
     * @param {string} realm realm name (not id!)
     * @param {string} executionId Execution id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationExecutionsExecutionIdGet(
      realm: string,
      executionId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmAuthenticationExecutionsExecutionIdGet(
          realm,
          executionId,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Lower execution’s priority
     * @param {string} realm realm name (not id!)
     * @param {string} executionId Execution id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationExecutionsExecutionIdLowerPriorityPost(
      realm: string,
      executionId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmAuthenticationExecutionsExecutionIdLowerPriorityPost(
          realm,
          executionId,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Raise execution’s priority
     * @param {string} realm realm name (not id!)
     * @param {string} executionId Execution id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationExecutionsExecutionIdRaisePriorityPost(
      realm: string,
      executionId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmAuthenticationExecutionsExecutionIdRaisePriorityPost(
          realm,
          executionId,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Add new authentication execution
     * @param {string} realm realm name (not id!)
     * @param {AuthenticationExecutionRepresentation} authenticationExecutionRepresentation JSON model describing authentication execution
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationExecutionsPost(
      realm: string,
      authenticationExecutionRepresentation: AuthenticationExecutionRepresentation,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmAuthenticationExecutionsPost(
          realm,
          authenticationExecutionRepresentation,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Copy existing authentication flow under a new name   The new name is given as \'newName\' attribute of the passed JSON object
     * @param {string} realm realm name (not id!)
     * @param {string} flowAlias Name of the existing authentication flow
     * @param {{ [key: string]: any; }} requestBody JSON containing \&#39;newName\&#39; attribute
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationFlowsFlowAliasCopyPost(
      realm: string,
      flowAlias: string,
      requestBody: { [key: string]: any },
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmAuthenticationFlowsFlowAliasCopyPost(
          realm,
          flowAlias,
          requestBody,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Add new authentication execution to a flow
     * @param {string} realm realm name (not id!)
     * @param {string} flowAlias Alias of parent flow
     * @param {{ [key: string]: any; }} requestBody New execution JSON data containing \&#39;provider\&#39; attribute
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationFlowsFlowAliasExecutionsExecutionPost(
      realm: string,
      flowAlias: string,
      requestBody: { [key: string]: any },
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmAuthenticationFlowsFlowAliasExecutionsExecutionPost(
          realm,
          flowAlias,
          requestBody,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Add new flow with new execution to existing flow
     * @param {string} realm realm name (not id!)
     * @param {string} flowAlias Alias of parent authentication flow
     * @param {{ [key: string]: any; }} requestBody New authentication flow / execution JSON data containing \&#39;alias\&#39;, \&#39;type\&#39;, \&#39;provider\&#39;, and \&#39;description\&#39; attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationFlowsFlowAliasExecutionsFlowPost(
      realm: string,
      flowAlias: string,
      requestBody: { [key: string]: any },
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmAuthenticationFlowsFlowAliasExecutionsFlowPost(
          realm,
          flowAlias,
          requestBody,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get authentication executions for a flow
     * @param {string} realm realm name (not id!)
     * @param {string} flowAlias Flow alias
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationFlowsFlowAliasExecutionsGet(
      realm: string,
      flowAlias: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmAuthenticationFlowsFlowAliasExecutionsGet(
          realm,
          flowAlias,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update authentication executions of a Flow
     * @param {string} realm realm name (not id!)
     * @param {string} flowAlias Flow alias
     * @param {AuthenticationExecutionInfoRepresentation} authenticationExecutionInfoRepresentation AuthenticationExecutionInfoRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationFlowsFlowAliasExecutionsPut(
      realm: string,
      flowAlias: string,
      authenticationExecutionInfoRepresentation: AuthenticationExecutionInfoRepresentation,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmAuthenticationFlowsFlowAliasExecutionsPut(
          realm,
          flowAlias,
          authenticationExecutionInfoRepresentation,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get authentication flows   Returns a stream of authentication flows.
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationFlowsGet(
      realm: string,
      options?: any
    ): AxiosPromise<Array<{ [key: string]: any }>> {
      return localVarFp
        .realmAuthenticationFlowsGet(realm, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete an authentication flow
     * @param {string} realm realm name (not id!)
     * @param {string} id Flow id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationFlowsIdDelete(
      realm: string,
      id: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmAuthenticationFlowsIdDelete(realm, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get authentication flow for id
     * @param {string} realm realm name (not id!)
     * @param {string} id Flow id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationFlowsIdGet(
      realm: string,
      id: string,
      options?: any
    ): AxiosPromise<AuthenticationFlowRepresentation> {
      return localVarFp
        .realmAuthenticationFlowsIdGet(realm, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update an authentication flow
     * @param {string} realm realm name (not id!)
     * @param {string} id Flow id
     * @param {AuthenticationFlowRepresentation} authenticationFlowRepresentation Authentication flow representation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationFlowsIdPut(
      realm: string,
      id: string,
      authenticationFlowRepresentation: AuthenticationFlowRepresentation,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmAuthenticationFlowsIdPut(
          realm,
          id,
          authenticationFlowRepresentation,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create a new authentication flow
     * @param {string} realm realm name (not id!)
     * @param {AuthenticationFlowRepresentation} authenticationFlowRepresentation Authentication flow representation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationFlowsPost(
      realm: string,
      authenticationFlowRepresentation: AuthenticationFlowRepresentation,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmAuthenticationFlowsPost(
          realm,
          authenticationFlowRepresentation,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get form action providers   Returns a stream of form action providers.
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationFormActionProvidersGet(
      realm: string,
      options?: any
    ): AxiosPromise<Array<{ [key: string]: any }>> {
      return localVarFp
        .realmAuthenticationFormActionProvidersGet(realm, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get form providers   Returns a stream of form providers.
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationFormProvidersGet(
      realm: string,
      options?: any
    ): AxiosPromise<Array<{ [key: string]: any }>> {
      return localVarFp
        .realmAuthenticationFormProvidersGet(realm, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get configuration descriptions for all clients
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationPerClientConfigDescriptionGet(
      realm: string,
      options?: any
    ): AxiosPromise<{ [key: string]: any }> {
      return localVarFp
        .realmAuthenticationPerClientConfigDescriptionGet(realm, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Register a new required actions
     * @param {string} realm realm name (not id!)
     * @param {{ [key: string]: any; }} requestBody JSON containing \&#39;providerId\&#39;, and \&#39;name\&#39; attributes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationRegisterRequiredActionPost(
      realm: string,
      requestBody: { [key: string]: any },
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmAuthenticationRegisterRequiredActionPost(
          realm,
          requestBody,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete required action
     * @param {string} realm realm name (not id!)
     * @param {string} alias Alias of required action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationRequiredActionsAliasDelete(
      realm: string,
      alias: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmAuthenticationRequiredActionsAliasDelete(realm, alias, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get required action for alias
     * @param {string} realm realm name (not id!)
     * @param {string} alias Alias of required action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationRequiredActionsAliasGet(
      realm: string,
      alias: string,
      options?: any
    ): AxiosPromise<RequiredActionProviderRepresentation> {
      return localVarFp
        .realmAuthenticationRequiredActionsAliasGet(realm, alias, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Lower required action’s priority
     * @param {string} realm realm name (not id!)
     * @param {string} alias Alias of required action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationRequiredActionsAliasLowerPriorityPost(
      realm: string,
      alias: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmAuthenticationRequiredActionsAliasLowerPriorityPost(
          realm,
          alias,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update required action
     * @param {string} realm realm name (not id!)
     * @param {string} alias Alias of required action
     * @param {RequiredActionProviderRepresentation} requiredActionProviderRepresentation JSON describing new state of required action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationRequiredActionsAliasPut(
      realm: string,
      alias: string,
      requiredActionProviderRepresentation: RequiredActionProviderRepresentation,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmAuthenticationRequiredActionsAliasPut(
          realm,
          alias,
          requiredActionProviderRepresentation,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Raise required action’s priority
     * @param {string} realm realm name (not id!)
     * @param {string} alias Alias of required action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationRequiredActionsAliasRaisePriorityPost(
      realm: string,
      alias: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmAuthenticationRequiredActionsAliasRaisePriorityPost(
          realm,
          alias,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get required actions   Returns a stream of required actions.
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationRequiredActionsGet(
      realm: string,
      options?: any
    ): AxiosPromise<Array<{ [key: string]: any }>> {
      return localVarFp
        .realmAuthenticationRequiredActionsGet(realm, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get unregistered required actions   Returns a stream of unregistered required actions.
     * @param {string} realm realm name (not id!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmAuthenticationUnregisteredRequiredActionsGet(
      realm: string,
      options?: any
    ): AxiosPromise<Array<{ [key: string]: any }>> {
      return localVarFp
        .realmAuthenticationUnregisteredRequiredActionsGet(realm, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AuthenticationManagementApi - object-oriented interface
 * @export
 * @class AuthenticationManagementApi
 * @extends {BaseAPI}
 */
export class AuthenticationManagementApi extends BaseAPI {
  /**
   *
   * @summary Get authenticator providers   Returns a stream of authenticator providers.
   * @param {string} realm realm name (not id!)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationManagementApi
   */
  public realmAuthenticationAuthenticatorProvidersGet(
    realm: string,
    options?: AxiosRequestConfig
  ) {
    return AuthenticationManagementApiFp(this.configuration)
      .realmAuthenticationAuthenticatorProvidersGet(realm, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get client authenticator providers   Returns a stream of client authenticator providers.
   * @param {string} realm realm name (not id!)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationManagementApi
   */
  public realmAuthenticationClientAuthenticatorProvidersGet(
    realm: string,
    options?: AxiosRequestConfig
  ) {
    return AuthenticationManagementApiFp(this.configuration)
      .realmAuthenticationClientAuthenticatorProvidersGet(realm, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get authenticator provider’s configuration description
   * @param {string} realm realm name (not id!)
   * @param {string} providerId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationManagementApi
   */
  public realmAuthenticationConfigDescriptionProviderIdGet(
    realm: string,
    providerId: string,
    options?: AxiosRequestConfig
  ) {
    return AuthenticationManagementApiFp(this.configuration)
      .realmAuthenticationConfigDescriptionProviderIdGet(
        realm,
        providerId,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete authenticator configuration
   * @param {string} realm realm name (not id!)
   * @param {string} id Configuration id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationManagementApi
   */
  public realmAuthenticationConfigIdDelete(
    realm: string,
    id: string,
    options?: AxiosRequestConfig
  ) {
    return AuthenticationManagementApiFp(this.configuration)
      .realmAuthenticationConfigIdDelete(realm, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get authenticator configuration
   * @param {string} realm realm name (not id!)
   * @param {string} id Configuration id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationManagementApi
   */
  public realmAuthenticationConfigIdGet(
    realm: string,
    id: string,
    options?: AxiosRequestConfig
  ) {
    return AuthenticationManagementApiFp(this.configuration)
      .realmAuthenticationConfigIdGet(realm, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update authenticator configuration
   * @param {string} realm realm name (not id!)
   * @param {string} id Configuration id
   * @param {AuthenticatorConfigRepresentation} authenticatorConfigRepresentation JSON describing new state of authenticator configuration
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationManagementApi
   */
  public realmAuthenticationConfigIdPut(
    realm: string,
    id: string,
    authenticatorConfigRepresentation: AuthenticatorConfigRepresentation,
    options?: AxiosRequestConfig
  ) {
    return AuthenticationManagementApiFp(this.configuration)
      .realmAuthenticationConfigIdPut(
        realm,
        id,
        authenticatorConfigRepresentation,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update execution with new configuration
   * @param {string} realm realm name (not id!)
   * @param {string} executionId Execution id
   * @param {AuthenticatorConfigRepresentation} authenticatorConfigRepresentation JSON with new configuration
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationManagementApi
   */
  public realmAuthenticationExecutionsExecutionIdConfigPost(
    realm: string,
    executionId: string,
    authenticatorConfigRepresentation: AuthenticatorConfigRepresentation,
    options?: AxiosRequestConfig
  ) {
    return AuthenticationManagementApiFp(this.configuration)
      .realmAuthenticationExecutionsExecutionIdConfigPost(
        realm,
        executionId,
        authenticatorConfigRepresentation,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete execution
   * @param {string} realm realm name (not id!)
   * @param {string} executionId Execution id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationManagementApi
   */
  public realmAuthenticationExecutionsExecutionIdDelete(
    realm: string,
    executionId: string,
    options?: AxiosRequestConfig
  ) {
    return AuthenticationManagementApiFp(this.configuration)
      .realmAuthenticationExecutionsExecutionIdDelete(
        realm,
        executionId,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Single Execution
   * @param {string} realm realm name (not id!)
   * @param {string} executionId Execution id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationManagementApi
   */
  public realmAuthenticationExecutionsExecutionIdGet(
    realm: string,
    executionId: string,
    options?: AxiosRequestConfig
  ) {
    return AuthenticationManagementApiFp(this.configuration)
      .realmAuthenticationExecutionsExecutionIdGet(realm, executionId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Lower execution’s priority
   * @param {string} realm realm name (not id!)
   * @param {string} executionId Execution id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationManagementApi
   */
  public realmAuthenticationExecutionsExecutionIdLowerPriorityPost(
    realm: string,
    executionId: string,
    options?: AxiosRequestConfig
  ) {
    return AuthenticationManagementApiFp(this.configuration)
      .realmAuthenticationExecutionsExecutionIdLowerPriorityPost(
        realm,
        executionId,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Raise execution’s priority
   * @param {string} realm realm name (not id!)
   * @param {string} executionId Execution id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationManagementApi
   */
  public realmAuthenticationExecutionsExecutionIdRaisePriorityPost(
    realm: string,
    executionId: string,
    options?: AxiosRequestConfig
  ) {
    return AuthenticationManagementApiFp(this.configuration)
      .realmAuthenticationExecutionsExecutionIdRaisePriorityPost(
        realm,
        executionId,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Add new authentication execution
   * @param {string} realm realm name (not id!)
   * @param {AuthenticationExecutionRepresentation} authenticationExecutionRepresentation JSON model describing authentication execution
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationManagementApi
   */
  public realmAuthenticationExecutionsPost(
    realm: string,
    authenticationExecutionRepresentation: AuthenticationExecutionRepresentation,
    options?: AxiosRequestConfig
  ) {
    return AuthenticationManagementApiFp(this.configuration)
      .realmAuthenticationExecutionsPost(
        realm,
        authenticationExecutionRepresentation,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Copy existing authentication flow under a new name   The new name is given as \'newName\' attribute of the passed JSON object
   * @param {string} realm realm name (not id!)
   * @param {string} flowAlias Name of the existing authentication flow
   * @param {{ [key: string]: any; }} requestBody JSON containing \&#39;newName\&#39; attribute
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationManagementApi
   */
  public realmAuthenticationFlowsFlowAliasCopyPost(
    realm: string,
    flowAlias: string,
    requestBody: { [key: string]: any },
    options?: AxiosRequestConfig
  ) {
    return AuthenticationManagementApiFp(this.configuration)
      .realmAuthenticationFlowsFlowAliasCopyPost(
        realm,
        flowAlias,
        requestBody,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Add new authentication execution to a flow
   * @param {string} realm realm name (not id!)
   * @param {string} flowAlias Alias of parent flow
   * @param {{ [key: string]: any; }} requestBody New execution JSON data containing \&#39;provider\&#39; attribute
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationManagementApi
   */
  public realmAuthenticationFlowsFlowAliasExecutionsExecutionPost(
    realm: string,
    flowAlias: string,
    requestBody: { [key: string]: any },
    options?: AxiosRequestConfig
  ) {
    return AuthenticationManagementApiFp(this.configuration)
      .realmAuthenticationFlowsFlowAliasExecutionsExecutionPost(
        realm,
        flowAlias,
        requestBody,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Add new flow with new execution to existing flow
   * @param {string} realm realm name (not id!)
   * @param {string} flowAlias Alias of parent authentication flow
   * @param {{ [key: string]: any; }} requestBody New authentication flow / execution JSON data containing \&#39;alias\&#39;, \&#39;type\&#39;, \&#39;provider\&#39;, and \&#39;description\&#39; attributes
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationManagementApi
   */
  public realmAuthenticationFlowsFlowAliasExecutionsFlowPost(
    realm: string,
    flowAlias: string,
    requestBody: { [key: string]: any },
    options?: AxiosRequestConfig
  ) {
    return AuthenticationManagementApiFp(this.configuration)
      .realmAuthenticationFlowsFlowAliasExecutionsFlowPost(
        realm,
        flowAlias,
        requestBody,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get authentication executions for a flow
   * @param {string} realm realm name (not id!)
   * @param {string} flowAlias Flow alias
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationManagementApi
   */
  public realmAuthenticationFlowsFlowAliasExecutionsGet(
    realm: string,
    flowAlias: string,
    options?: AxiosRequestConfig
  ) {
    return AuthenticationManagementApiFp(this.configuration)
      .realmAuthenticationFlowsFlowAliasExecutionsGet(realm, flowAlias, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update authentication executions of a Flow
   * @param {string} realm realm name (not id!)
   * @param {string} flowAlias Flow alias
   * @param {AuthenticationExecutionInfoRepresentation} authenticationExecutionInfoRepresentation AuthenticationExecutionInfoRepresentation
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationManagementApi
   */
  public realmAuthenticationFlowsFlowAliasExecutionsPut(
    realm: string,
    flowAlias: string,
    authenticationExecutionInfoRepresentation: AuthenticationExecutionInfoRepresentation,
    options?: AxiosRequestConfig
  ) {
    return AuthenticationManagementApiFp(this.configuration)
      .realmAuthenticationFlowsFlowAliasExecutionsPut(
        realm,
        flowAlias,
        authenticationExecutionInfoRepresentation,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get authentication flows   Returns a stream of authentication flows.
   * @param {string} realm realm name (not id!)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationManagementApi
   */
  public realmAuthenticationFlowsGet(
    realm: string,
    options?: AxiosRequestConfig
  ) {
    return AuthenticationManagementApiFp(this.configuration)
      .realmAuthenticationFlowsGet(realm, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete an authentication flow
   * @param {string} realm realm name (not id!)
   * @param {string} id Flow id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationManagementApi
   */
  public realmAuthenticationFlowsIdDelete(
    realm: string,
    id: string,
    options?: AxiosRequestConfig
  ) {
    return AuthenticationManagementApiFp(this.configuration)
      .realmAuthenticationFlowsIdDelete(realm, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get authentication flow for id
   * @param {string} realm realm name (not id!)
   * @param {string} id Flow id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationManagementApi
   */
  public realmAuthenticationFlowsIdGet(
    realm: string,
    id: string,
    options?: AxiosRequestConfig
  ) {
    return AuthenticationManagementApiFp(this.configuration)
      .realmAuthenticationFlowsIdGet(realm, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update an authentication flow
   * @param {string} realm realm name (not id!)
   * @param {string} id Flow id
   * @param {AuthenticationFlowRepresentation} authenticationFlowRepresentation Authentication flow representation
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationManagementApi
   */
  public realmAuthenticationFlowsIdPut(
    realm: string,
    id: string,
    authenticationFlowRepresentation: AuthenticationFlowRepresentation,
    options?: AxiosRequestConfig
  ) {
    return AuthenticationManagementApiFp(this.configuration)
      .realmAuthenticationFlowsIdPut(
        realm,
        id,
        authenticationFlowRepresentation,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create a new authentication flow
   * @param {string} realm realm name (not id!)
   * @param {AuthenticationFlowRepresentation} authenticationFlowRepresentation Authentication flow representation
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationManagementApi
   */
  public realmAuthenticationFlowsPost(
    realm: string,
    authenticationFlowRepresentation: AuthenticationFlowRepresentation,
    options?: AxiosRequestConfig
  ) {
    return AuthenticationManagementApiFp(this.configuration)
      .realmAuthenticationFlowsPost(
        realm,
        authenticationFlowRepresentation,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get form action providers   Returns a stream of form action providers.
   * @param {string} realm realm name (not id!)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationManagementApi
   */
  public realmAuthenticationFormActionProvidersGet(
    realm: string,
    options?: AxiosRequestConfig
  ) {
    return AuthenticationManagementApiFp(this.configuration)
      .realmAuthenticationFormActionProvidersGet(realm, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get form providers   Returns a stream of form providers.
   * @param {string} realm realm name (not id!)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationManagementApi
   */
  public realmAuthenticationFormProvidersGet(
    realm: string,
    options?: AxiosRequestConfig
  ) {
    return AuthenticationManagementApiFp(this.configuration)
      .realmAuthenticationFormProvidersGet(realm, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get configuration descriptions for all clients
   * @param {string} realm realm name (not id!)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationManagementApi
   */
  public realmAuthenticationPerClientConfigDescriptionGet(
    realm: string,
    options?: AxiosRequestConfig
  ) {
    return AuthenticationManagementApiFp(this.configuration)
      .realmAuthenticationPerClientConfigDescriptionGet(realm, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Register a new required actions
   * @param {string} realm realm name (not id!)
   * @param {{ [key: string]: any; }} requestBody JSON containing \&#39;providerId\&#39;, and \&#39;name\&#39; attributes.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationManagementApi
   */
  public realmAuthenticationRegisterRequiredActionPost(
    realm: string,
    requestBody: { [key: string]: any },
    options?: AxiosRequestConfig
  ) {
    return AuthenticationManagementApiFp(this.configuration)
      .realmAuthenticationRegisterRequiredActionPost(
        realm,
        requestBody,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete required action
   * @param {string} realm realm name (not id!)
   * @param {string} alias Alias of required action
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationManagementApi
   */
  public realmAuthenticationRequiredActionsAliasDelete(
    realm: string,
    alias: string,
    options?: AxiosRequestConfig
  ) {
    return AuthenticationManagementApiFp(this.configuration)
      .realmAuthenticationRequiredActionsAliasDelete(realm, alias, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get required action for alias
   * @param {string} realm realm name (not id!)
   * @param {string} alias Alias of required action
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationManagementApi
   */
  public realmAuthenticationRequiredActionsAliasGet(
    realm: string,
    alias: string,
    options?: AxiosRequestConfig
  ) {
    return AuthenticationManagementApiFp(this.configuration)
      .realmAuthenticationRequiredActionsAliasGet(realm, alias, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Lower required action’s priority
   * @param {string} realm realm name (not id!)
   * @param {string} alias Alias of required action
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationManagementApi
   */
  public realmAuthenticationRequiredActionsAliasLowerPriorityPost(
    realm: string,
    alias: string,
    options?: AxiosRequestConfig
  ) {
    return AuthenticationManagementApiFp(this.configuration)
      .realmAuthenticationRequiredActionsAliasLowerPriorityPost(
        realm,
        alias,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update required action
   * @param {string} realm realm name (not id!)
   * @param {string} alias Alias of required action
   * @param {RequiredActionProviderRepresentation} requiredActionProviderRepresentation JSON describing new state of required action
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationManagementApi
   */
  public realmAuthenticationRequiredActionsAliasPut(
    realm: string,
    alias: string,
    requiredActionProviderRepresentation: RequiredActionProviderRepresentation,
    options?: AxiosRequestConfig
  ) {
    return AuthenticationManagementApiFp(this.configuration)
      .realmAuthenticationRequiredActionsAliasPut(
        realm,
        alias,
        requiredActionProviderRepresentation,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Raise required action’s priority
   * @param {string} realm realm name (not id!)
   * @param {string} alias Alias of required action
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationManagementApi
   */
  public realmAuthenticationRequiredActionsAliasRaisePriorityPost(
    realm: string,
    alias: string,
    options?: AxiosRequestConfig
  ) {
    return AuthenticationManagementApiFp(this.configuration)
      .realmAuthenticationRequiredActionsAliasRaisePriorityPost(
        realm,
        alias,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get required actions   Returns a stream of required actions.
   * @param {string} realm realm name (not id!)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationManagementApi
   */
  public realmAuthenticationRequiredActionsGet(
    realm: string,
    options?: AxiosRequestConfig
  ) {
    return AuthenticationManagementApiFp(this.configuration)
      .realmAuthenticationRequiredActionsGet(realm, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get unregistered required actions   Returns a stream of unregistered required actions.
   * @param {string} realm realm name (not id!)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationManagementApi
   */
  public realmAuthenticationUnregisteredRequiredActionsGet(
    realm: string,
    options?: AxiosRequestConfig
  ) {
    return AuthenticationManagementApiFp(this.configuration)
      .realmAuthenticationUnregisteredRequiredActionsGet(realm, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
