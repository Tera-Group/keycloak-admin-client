/* tslint:disable */
/* eslint-disable */
/**
 * Keycloak Admin REST API
 * This is a REST API reference for the Keycloak Admin REST API.
 *
 * The version of the OpenAPI document: 1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from '../common';
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from '../base';
// @ts-ignore
import { RoleRepresentation } from '../model';
/**
 * ScopeMappingsApi - axios parameter creator
 * @export
 */
export const ScopeMappingsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary The available client-level roles   Returns the roles for the client that can be associated with the client’s scope
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client scope (not name)
     * @param {string} client
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientScopesIdScopeMappingsClientsClientAvailableGet: async (
      realm: string,
      id: string,
      client: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmClientScopesIdScopeMappingsClientsClientAvailableGet',
        'realm',
        realm
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists(
        'realmClientScopesIdScopeMappingsClientsClientAvailableGet',
        'id',
        id
      );
      // verify required parameter 'client' is not null or undefined
      assertParamExists(
        'realmClientScopesIdScopeMappingsClientsClientAvailableGet',
        'client',
        client
      );
      const localVarPath =
        `/{realm}/client-scopes/{id}/scope-mappings/clients/{client}/available`
          .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
          .replace(`{${'id'}}`, encodeURIComponent(String(id)))
          .replace(`{${'client'}}`, encodeURIComponent(String(client)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get effective client roles   Returns the roles for the client that are associated with the client’s scope.
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client scope (not name)
     * @param {string} client
     * @param {boolean} [briefRepresentation] if false, return roles with their attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientScopesIdScopeMappingsClientsClientCompositeGet: async (
      realm: string,
      id: string,
      client: string,
      briefRepresentation?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmClientScopesIdScopeMappingsClientsClientCompositeGet',
        'realm',
        realm
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists(
        'realmClientScopesIdScopeMappingsClientsClientCompositeGet',
        'id',
        id
      );
      // verify required parameter 'client' is not null or undefined
      assertParamExists(
        'realmClientScopesIdScopeMappingsClientsClientCompositeGet',
        'client',
        client
      );
      const localVarPath =
        `/{realm}/client-scopes/{id}/scope-mappings/clients/{client}/composite`
          .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
          .replace(`{${'id'}}`, encodeURIComponent(String(id)))
          .replace(`{${'client'}}`, encodeURIComponent(String(client)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (briefRepresentation !== undefined) {
        localVarQueryParameter['briefRepresentation'] = briefRepresentation;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Remove client-level roles from the client’s scope.
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client scope (not name)
     * @param {string} client
     * @param {Array<RoleRepresentation>} roleRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientScopesIdScopeMappingsClientsClientDelete: async (
      realm: string,
      id: string,
      client: string,
      roleRepresentation: Array<RoleRepresentation>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmClientScopesIdScopeMappingsClientsClientDelete',
        'realm',
        realm
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists(
        'realmClientScopesIdScopeMappingsClientsClientDelete',
        'id',
        id
      );
      // verify required parameter 'client' is not null or undefined
      assertParamExists(
        'realmClientScopesIdScopeMappingsClientsClientDelete',
        'client',
        client
      );
      // verify required parameter 'roleRepresentation' is not null or undefined
      assertParamExists(
        'realmClientScopesIdScopeMappingsClientsClientDelete',
        'roleRepresentation',
        roleRepresentation
      );
      const localVarPath =
        `/{realm}/client-scopes/{id}/scope-mappings/clients/{client}`
          .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
          .replace(`{${'id'}}`, encodeURIComponent(String(id)))
          .replace(`{${'client'}}`, encodeURIComponent(String(client)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        roleRepresentation,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the roles associated with a client’s scope   Returns roles for the client.
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client scope (not name)
     * @param {string} client
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientScopesIdScopeMappingsClientsClientGet: async (
      realm: string,
      id: string,
      client: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmClientScopesIdScopeMappingsClientsClientGet',
        'realm',
        realm
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists(
        'realmClientScopesIdScopeMappingsClientsClientGet',
        'id',
        id
      );
      // verify required parameter 'client' is not null or undefined
      assertParamExists(
        'realmClientScopesIdScopeMappingsClientsClientGet',
        'client',
        client
      );
      const localVarPath =
        `/{realm}/client-scopes/{id}/scope-mappings/clients/{client}`
          .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
          .replace(`{${'id'}}`, encodeURIComponent(String(id)))
          .replace(`{${'client'}}`, encodeURIComponent(String(client)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Add client-level roles to the client’s scope
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client scope (not name)
     * @param {string} client
     * @param {Array<RoleRepresentation>} roleRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientScopesIdScopeMappingsClientsClientPost: async (
      realm: string,
      id: string,
      client: string,
      roleRepresentation: Array<RoleRepresentation>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmClientScopesIdScopeMappingsClientsClientPost',
        'realm',
        realm
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists(
        'realmClientScopesIdScopeMappingsClientsClientPost',
        'id',
        id
      );
      // verify required parameter 'client' is not null or undefined
      assertParamExists(
        'realmClientScopesIdScopeMappingsClientsClientPost',
        'client',
        client
      );
      // verify required parameter 'roleRepresentation' is not null or undefined
      assertParamExists(
        'realmClientScopesIdScopeMappingsClientsClientPost',
        'roleRepresentation',
        roleRepresentation
      );
      const localVarPath =
        `/{realm}/client-scopes/{id}/scope-mappings/clients/{client}`
          .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
          .replace(`{${'id'}}`, encodeURIComponent(String(id)))
          .replace(`{${'client'}}`, encodeURIComponent(String(client)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        roleRepresentation,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get realm-level roles that are available to attach to this client’s scope
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client scope (not name)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientScopesIdScopeMappingsRealmAvailableGet: async (
      realm: string,
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmClientScopesIdScopeMappingsRealmAvailableGet',
        'realm',
        realm
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists(
        'realmClientScopesIdScopeMappingsRealmAvailableGet',
        'id',
        id
      );
      const localVarPath =
        `/{realm}/client-scopes/{id}/scope-mappings/realm/available`
          .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
          .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get effective realm-level roles associated with the client’s scope   What this does is recurse  any composite roles associated with the client’s scope and adds the roles to this lists.
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client scope (not name)
     * @param {boolean} [briefRepresentation] if false, return roles with their attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientScopesIdScopeMappingsRealmCompositeGet: async (
      realm: string,
      id: string,
      briefRepresentation?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmClientScopesIdScopeMappingsRealmCompositeGet',
        'realm',
        realm
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists(
        'realmClientScopesIdScopeMappingsRealmCompositeGet',
        'id',
        id
      );
      const localVarPath =
        `/{realm}/client-scopes/{id}/scope-mappings/realm/composite`
          .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
          .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (briefRepresentation !== undefined) {
        localVarQueryParameter['briefRepresentation'] = briefRepresentation;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Remove a set of realm-level roles from the client’s scope
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client scope (not name)
     * @param {Array<RoleRepresentation>} roleRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientScopesIdScopeMappingsRealmDelete: async (
      realm: string,
      id: string,
      roleRepresentation: Array<RoleRepresentation>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmClientScopesIdScopeMappingsRealmDelete',
        'realm',
        realm
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists(
        'realmClientScopesIdScopeMappingsRealmDelete',
        'id',
        id
      );
      // verify required parameter 'roleRepresentation' is not null or undefined
      assertParamExists(
        'realmClientScopesIdScopeMappingsRealmDelete',
        'roleRepresentation',
        roleRepresentation
      );
      const localVarPath = `/{realm}/client-scopes/{id}/scope-mappings/realm`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        roleRepresentation,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get realm-level roles associated with the client’s scope
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client scope (not name)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientScopesIdScopeMappingsRealmGet: async (
      realm: string,
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmClientScopesIdScopeMappingsRealmGet',
        'realm',
        realm
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmClientScopesIdScopeMappingsRealmGet', 'id', id);
      const localVarPath = `/{realm}/client-scopes/{id}/scope-mappings/realm`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Add a set of realm-level roles to the client’s scope
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client scope (not name)
     * @param {Array<RoleRepresentation>} roleRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientScopesIdScopeMappingsRealmPost: async (
      realm: string,
      id: string,
      roleRepresentation: Array<RoleRepresentation>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmClientScopesIdScopeMappingsRealmPost',
        'realm',
        realm
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmClientScopesIdScopeMappingsRealmPost', 'id', id);
      // verify required parameter 'roleRepresentation' is not null or undefined
      assertParamExists(
        'realmClientScopesIdScopeMappingsRealmPost',
        'roleRepresentation',
        roleRepresentation
      );
      const localVarPath = `/{realm}/client-scopes/{id}/scope-mappings/realm`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        roleRepresentation,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary The available client-level roles   Returns the roles for the client that can be associated with the client’s scope
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} client
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdScopeMappingsClientsClientAvailableGet: async (
      realm: string,
      id: string,
      client: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmClientsIdScopeMappingsClientsClientAvailableGet',
        'realm',
        realm
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists(
        'realmClientsIdScopeMappingsClientsClientAvailableGet',
        'id',
        id
      );
      // verify required parameter 'client' is not null or undefined
      assertParamExists(
        'realmClientsIdScopeMappingsClientsClientAvailableGet',
        'client',
        client
      );
      const localVarPath =
        `/{realm}/clients/{id}/scope-mappings/clients/{client}/available`
          .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
          .replace(`{${'id'}}`, encodeURIComponent(String(id)))
          .replace(`{${'client'}}`, encodeURIComponent(String(client)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get effective client roles   Returns the roles for the client that are associated with the client’s scope.
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} client
     * @param {boolean} [briefRepresentation] if false, return roles with their attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdScopeMappingsClientsClientCompositeGet: async (
      realm: string,
      id: string,
      client: string,
      briefRepresentation?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmClientsIdScopeMappingsClientsClientCompositeGet',
        'realm',
        realm
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists(
        'realmClientsIdScopeMappingsClientsClientCompositeGet',
        'id',
        id
      );
      // verify required parameter 'client' is not null or undefined
      assertParamExists(
        'realmClientsIdScopeMappingsClientsClientCompositeGet',
        'client',
        client
      );
      const localVarPath =
        `/{realm}/clients/{id}/scope-mappings/clients/{client}/composite`
          .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
          .replace(`{${'id'}}`, encodeURIComponent(String(id)))
          .replace(`{${'client'}}`, encodeURIComponent(String(client)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (briefRepresentation !== undefined) {
        localVarQueryParameter['briefRepresentation'] = briefRepresentation;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Remove client-level roles from the client’s scope.
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} client
     * @param {Array<RoleRepresentation>} roleRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdScopeMappingsClientsClientDelete: async (
      realm: string,
      id: string,
      client: string,
      roleRepresentation: Array<RoleRepresentation>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmClientsIdScopeMappingsClientsClientDelete',
        'realm',
        realm
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists(
        'realmClientsIdScopeMappingsClientsClientDelete',
        'id',
        id
      );
      // verify required parameter 'client' is not null or undefined
      assertParamExists(
        'realmClientsIdScopeMappingsClientsClientDelete',
        'client',
        client
      );
      // verify required parameter 'roleRepresentation' is not null or undefined
      assertParamExists(
        'realmClientsIdScopeMappingsClientsClientDelete',
        'roleRepresentation',
        roleRepresentation
      );
      const localVarPath =
        `/{realm}/clients/{id}/scope-mappings/clients/{client}`
          .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
          .replace(`{${'id'}}`, encodeURIComponent(String(id)))
          .replace(`{${'client'}}`, encodeURIComponent(String(client)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        roleRepresentation,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the roles associated with a client’s scope   Returns roles for the client.
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} client
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdScopeMappingsClientsClientGet: async (
      realm: string,
      id: string,
      client: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmClientsIdScopeMappingsClientsClientGet',
        'realm',
        realm
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists(
        'realmClientsIdScopeMappingsClientsClientGet',
        'id',
        id
      );
      // verify required parameter 'client' is not null or undefined
      assertParamExists(
        'realmClientsIdScopeMappingsClientsClientGet',
        'client',
        client
      );
      const localVarPath =
        `/{realm}/clients/{id}/scope-mappings/clients/{client}`
          .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
          .replace(`{${'id'}}`, encodeURIComponent(String(id)))
          .replace(`{${'client'}}`, encodeURIComponent(String(client)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Add client-level roles to the client’s scope
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} client
     * @param {Array<RoleRepresentation>} roleRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdScopeMappingsClientsClientPost: async (
      realm: string,
      id: string,
      client: string,
      roleRepresentation: Array<RoleRepresentation>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmClientsIdScopeMappingsClientsClientPost',
        'realm',
        realm
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists(
        'realmClientsIdScopeMappingsClientsClientPost',
        'id',
        id
      );
      // verify required parameter 'client' is not null or undefined
      assertParamExists(
        'realmClientsIdScopeMappingsClientsClientPost',
        'client',
        client
      );
      // verify required parameter 'roleRepresentation' is not null or undefined
      assertParamExists(
        'realmClientsIdScopeMappingsClientsClientPost',
        'roleRepresentation',
        roleRepresentation
      );
      const localVarPath =
        `/{realm}/clients/{id}/scope-mappings/clients/{client}`
          .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
          .replace(`{${'id'}}`, encodeURIComponent(String(id)))
          .replace(`{${'client'}}`, encodeURIComponent(String(client)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        roleRepresentation,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get realm-level roles that are available to attach to this client’s scope
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdScopeMappingsRealmAvailableGet: async (
      realm: string,
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmClientsIdScopeMappingsRealmAvailableGet',
        'realm',
        realm
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists(
        'realmClientsIdScopeMappingsRealmAvailableGet',
        'id',
        id
      );
      const localVarPath =
        `/{realm}/clients/{id}/scope-mappings/realm/available`
          .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
          .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get effective realm-level roles associated with the client’s scope   What this does is recurse  any composite roles associated with the client’s scope and adds the roles to this lists.
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {boolean} [briefRepresentation] if false, return roles with their attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdScopeMappingsRealmCompositeGet: async (
      realm: string,
      id: string,
      briefRepresentation?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmClientsIdScopeMappingsRealmCompositeGet',
        'realm',
        realm
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists(
        'realmClientsIdScopeMappingsRealmCompositeGet',
        'id',
        id
      );
      const localVarPath =
        `/{realm}/clients/{id}/scope-mappings/realm/composite`
          .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
          .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (briefRepresentation !== undefined) {
        localVarQueryParameter['briefRepresentation'] = briefRepresentation;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Remove a set of realm-level roles from the client’s scope
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {Array<RoleRepresentation>} roleRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdScopeMappingsRealmDelete: async (
      realm: string,
      id: string,
      roleRepresentation: Array<RoleRepresentation>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmClientsIdScopeMappingsRealmDelete',
        'realm',
        realm
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmClientsIdScopeMappingsRealmDelete', 'id', id);
      // verify required parameter 'roleRepresentation' is not null or undefined
      assertParamExists(
        'realmClientsIdScopeMappingsRealmDelete',
        'roleRepresentation',
        roleRepresentation
      );
      const localVarPath = `/{realm}/clients/{id}/scope-mappings/realm`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        roleRepresentation,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get realm-level roles associated with the client’s scope
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdScopeMappingsRealmGet: async (
      realm: string,
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmClientsIdScopeMappingsRealmGet', 'realm', realm);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmClientsIdScopeMappingsRealmGet', 'id', id);
      const localVarPath = `/{realm}/clients/{id}/scope-mappings/realm`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Add a set of realm-level roles to the client’s scope
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {Array<RoleRepresentation>} roleRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdScopeMappingsRealmPost: async (
      realm: string,
      id: string,
      roleRepresentation: Array<RoleRepresentation>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmClientsIdScopeMappingsRealmPost', 'realm', realm);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmClientsIdScopeMappingsRealmPost', 'id', id);
      // verify required parameter 'roleRepresentation' is not null or undefined
      assertParamExists(
        'realmClientsIdScopeMappingsRealmPost',
        'roleRepresentation',
        roleRepresentation
      );
      const localVarPath = `/{realm}/clients/{id}/scope-mappings/realm`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        roleRepresentation,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ScopeMappingsApi - functional programming interface
 * @export
 */
export const ScopeMappingsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ScopeMappingsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary The available client-level roles   Returns the roles for the client that can be associated with the client’s scope
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client scope (not name)
     * @param {string} client
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientScopesIdScopeMappingsClientsClientAvailableGet(
      realm: string,
      id: string,
      client: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<{ [key: string]: any }>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientScopesIdScopeMappingsClientsClientAvailableGet(
          realm,
          id,
          client,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get effective client roles   Returns the roles for the client that are associated with the client’s scope.
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client scope (not name)
     * @param {string} client
     * @param {boolean} [briefRepresentation] if false, return roles with their attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientScopesIdScopeMappingsClientsClientCompositeGet(
      realm: string,
      id: string,
      client: string,
      briefRepresentation?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<{ [key: string]: any }>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientScopesIdScopeMappingsClientsClientCompositeGet(
          realm,
          id,
          client,
          briefRepresentation,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Remove client-level roles from the client’s scope.
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client scope (not name)
     * @param {string} client
     * @param {Array<RoleRepresentation>} roleRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientScopesIdScopeMappingsClientsClientDelete(
      realm: string,
      id: string,
      client: string,
      roleRepresentation: Array<RoleRepresentation>,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientScopesIdScopeMappingsClientsClientDelete(
          realm,
          id,
          client,
          roleRepresentation,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get the roles associated with a client’s scope   Returns roles for the client.
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client scope (not name)
     * @param {string} client
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientScopesIdScopeMappingsClientsClientGet(
      realm: string,
      id: string,
      client: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<{ [key: string]: any }>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientScopesIdScopeMappingsClientsClientGet(
          realm,
          id,
          client,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Add client-level roles to the client’s scope
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client scope (not name)
     * @param {string} client
     * @param {Array<RoleRepresentation>} roleRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientScopesIdScopeMappingsClientsClientPost(
      realm: string,
      id: string,
      client: string,
      roleRepresentation: Array<RoleRepresentation>,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientScopesIdScopeMappingsClientsClientPost(
          realm,
          id,
          client,
          roleRepresentation,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get realm-level roles that are available to attach to this client’s scope
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client scope (not name)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientScopesIdScopeMappingsRealmAvailableGet(
      realm: string,
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<{ [key: string]: any }>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientScopesIdScopeMappingsRealmAvailableGet(
          realm,
          id,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get effective realm-level roles associated with the client’s scope   What this does is recurse  any composite roles associated with the client’s scope and adds the roles to this lists.
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client scope (not name)
     * @param {boolean} [briefRepresentation] if false, return roles with their attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientScopesIdScopeMappingsRealmCompositeGet(
      realm: string,
      id: string,
      briefRepresentation?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<{ [key: string]: any }>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientScopesIdScopeMappingsRealmCompositeGet(
          realm,
          id,
          briefRepresentation,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Remove a set of realm-level roles from the client’s scope
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client scope (not name)
     * @param {Array<RoleRepresentation>} roleRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientScopesIdScopeMappingsRealmDelete(
      realm: string,
      id: string,
      roleRepresentation: Array<RoleRepresentation>,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientScopesIdScopeMappingsRealmDelete(
          realm,
          id,
          roleRepresentation,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get realm-level roles associated with the client’s scope
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client scope (not name)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientScopesIdScopeMappingsRealmGet(
      realm: string,
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<{ [key: string]: any }>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientScopesIdScopeMappingsRealmGet(
          realm,
          id,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Add a set of realm-level roles to the client’s scope
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client scope (not name)
     * @param {Array<RoleRepresentation>} roleRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientScopesIdScopeMappingsRealmPost(
      realm: string,
      id: string,
      roleRepresentation: Array<RoleRepresentation>,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientScopesIdScopeMappingsRealmPost(
          realm,
          id,
          roleRepresentation,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary The available client-level roles   Returns the roles for the client that can be associated with the client’s scope
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} client
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientsIdScopeMappingsClientsClientAvailableGet(
      realm: string,
      id: string,
      client: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<{ [key: string]: any }>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientsIdScopeMappingsClientsClientAvailableGet(
          realm,
          id,
          client,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get effective client roles   Returns the roles for the client that are associated with the client’s scope.
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} client
     * @param {boolean} [briefRepresentation] if false, return roles with their attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientsIdScopeMappingsClientsClientCompositeGet(
      realm: string,
      id: string,
      client: string,
      briefRepresentation?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<{ [key: string]: any }>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientsIdScopeMappingsClientsClientCompositeGet(
          realm,
          id,
          client,
          briefRepresentation,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Remove client-level roles from the client’s scope.
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} client
     * @param {Array<RoleRepresentation>} roleRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientsIdScopeMappingsClientsClientDelete(
      realm: string,
      id: string,
      client: string,
      roleRepresentation: Array<RoleRepresentation>,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientsIdScopeMappingsClientsClientDelete(
          realm,
          id,
          client,
          roleRepresentation,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get the roles associated with a client’s scope   Returns roles for the client.
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} client
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientsIdScopeMappingsClientsClientGet(
      realm: string,
      id: string,
      client: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<{ [key: string]: any }>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientsIdScopeMappingsClientsClientGet(
          realm,
          id,
          client,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Add client-level roles to the client’s scope
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} client
     * @param {Array<RoleRepresentation>} roleRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientsIdScopeMappingsClientsClientPost(
      realm: string,
      id: string,
      client: string,
      roleRepresentation: Array<RoleRepresentation>,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientsIdScopeMappingsClientsClientPost(
          realm,
          id,
          client,
          roleRepresentation,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get realm-level roles that are available to attach to this client’s scope
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientsIdScopeMappingsRealmAvailableGet(
      realm: string,
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<{ [key: string]: any }>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientsIdScopeMappingsRealmAvailableGet(
          realm,
          id,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get effective realm-level roles associated with the client’s scope   What this does is recurse  any composite roles associated with the client’s scope and adds the roles to this lists.
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {boolean} [briefRepresentation] if false, return roles with their attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientsIdScopeMappingsRealmCompositeGet(
      realm: string,
      id: string,
      briefRepresentation?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<{ [key: string]: any }>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientsIdScopeMappingsRealmCompositeGet(
          realm,
          id,
          briefRepresentation,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Remove a set of realm-level roles from the client’s scope
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {Array<RoleRepresentation>} roleRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientsIdScopeMappingsRealmDelete(
      realm: string,
      id: string,
      roleRepresentation: Array<RoleRepresentation>,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientsIdScopeMappingsRealmDelete(
          realm,
          id,
          roleRepresentation,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get realm-level roles associated with the client’s scope
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientsIdScopeMappingsRealmGet(
      realm: string,
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<{ [key: string]: any }>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientsIdScopeMappingsRealmGet(
          realm,
          id,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Add a set of realm-level roles to the client’s scope
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {Array<RoleRepresentation>} roleRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmClientsIdScopeMappingsRealmPost(
      realm: string,
      id: string,
      roleRepresentation: Array<RoleRepresentation>,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmClientsIdScopeMappingsRealmPost(
          realm,
          id,
          roleRepresentation,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * ScopeMappingsApi - factory interface
 * @export
 */
export const ScopeMappingsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ScopeMappingsApiFp(configuration);
  return {
    /**
     *
     * @summary The available client-level roles   Returns the roles for the client that can be associated with the client’s scope
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client scope (not name)
     * @param {string} client
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientScopesIdScopeMappingsClientsClientAvailableGet(
      realm: string,
      id: string,
      client: string,
      options?: any
    ): AxiosPromise<Array<{ [key: string]: any }>> {
      return localVarFp
        .realmClientScopesIdScopeMappingsClientsClientAvailableGet(
          realm,
          id,
          client,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get effective client roles   Returns the roles for the client that are associated with the client’s scope.
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client scope (not name)
     * @param {string} client
     * @param {boolean} [briefRepresentation] if false, return roles with their attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientScopesIdScopeMappingsClientsClientCompositeGet(
      realm: string,
      id: string,
      client: string,
      briefRepresentation?: boolean,
      options?: any
    ): AxiosPromise<Array<{ [key: string]: any }>> {
      return localVarFp
        .realmClientScopesIdScopeMappingsClientsClientCompositeGet(
          realm,
          id,
          client,
          briefRepresentation,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Remove client-level roles from the client’s scope.
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client scope (not name)
     * @param {string} client
     * @param {Array<RoleRepresentation>} roleRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientScopesIdScopeMappingsClientsClientDelete(
      realm: string,
      id: string,
      client: string,
      roleRepresentation: Array<RoleRepresentation>,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmClientScopesIdScopeMappingsClientsClientDelete(
          realm,
          id,
          client,
          roleRepresentation,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get the roles associated with a client’s scope   Returns roles for the client.
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client scope (not name)
     * @param {string} client
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientScopesIdScopeMappingsClientsClientGet(
      realm: string,
      id: string,
      client: string,
      options?: any
    ): AxiosPromise<Array<{ [key: string]: any }>> {
      return localVarFp
        .realmClientScopesIdScopeMappingsClientsClientGet(
          realm,
          id,
          client,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Add client-level roles to the client’s scope
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client scope (not name)
     * @param {string} client
     * @param {Array<RoleRepresentation>} roleRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientScopesIdScopeMappingsClientsClientPost(
      realm: string,
      id: string,
      client: string,
      roleRepresentation: Array<RoleRepresentation>,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmClientScopesIdScopeMappingsClientsClientPost(
          realm,
          id,
          client,
          roleRepresentation,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get realm-level roles that are available to attach to this client’s scope
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client scope (not name)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientScopesIdScopeMappingsRealmAvailableGet(
      realm: string,
      id: string,
      options?: any
    ): AxiosPromise<Array<{ [key: string]: any }>> {
      return localVarFp
        .realmClientScopesIdScopeMappingsRealmAvailableGet(realm, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get effective realm-level roles associated with the client’s scope   What this does is recurse  any composite roles associated with the client’s scope and adds the roles to this lists.
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client scope (not name)
     * @param {boolean} [briefRepresentation] if false, return roles with their attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientScopesIdScopeMappingsRealmCompositeGet(
      realm: string,
      id: string,
      briefRepresentation?: boolean,
      options?: any
    ): AxiosPromise<Array<{ [key: string]: any }>> {
      return localVarFp
        .realmClientScopesIdScopeMappingsRealmCompositeGet(
          realm,
          id,
          briefRepresentation,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Remove a set of realm-level roles from the client’s scope
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client scope (not name)
     * @param {Array<RoleRepresentation>} roleRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientScopesIdScopeMappingsRealmDelete(
      realm: string,
      id: string,
      roleRepresentation: Array<RoleRepresentation>,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmClientScopesIdScopeMappingsRealmDelete(
          realm,
          id,
          roleRepresentation,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get realm-level roles associated with the client’s scope
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client scope (not name)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientScopesIdScopeMappingsRealmGet(
      realm: string,
      id: string,
      options?: any
    ): AxiosPromise<Array<{ [key: string]: any }>> {
      return localVarFp
        .realmClientScopesIdScopeMappingsRealmGet(realm, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Add a set of realm-level roles to the client’s scope
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client scope (not name)
     * @param {Array<RoleRepresentation>} roleRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientScopesIdScopeMappingsRealmPost(
      realm: string,
      id: string,
      roleRepresentation: Array<RoleRepresentation>,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmClientScopesIdScopeMappingsRealmPost(
          realm,
          id,
          roleRepresentation,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary The available client-level roles   Returns the roles for the client that can be associated with the client’s scope
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} client
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdScopeMappingsClientsClientAvailableGet(
      realm: string,
      id: string,
      client: string,
      options?: any
    ): AxiosPromise<Array<{ [key: string]: any }>> {
      return localVarFp
        .realmClientsIdScopeMappingsClientsClientAvailableGet(
          realm,
          id,
          client,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get effective client roles   Returns the roles for the client that are associated with the client’s scope.
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} client
     * @param {boolean} [briefRepresentation] if false, return roles with their attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdScopeMappingsClientsClientCompositeGet(
      realm: string,
      id: string,
      client: string,
      briefRepresentation?: boolean,
      options?: any
    ): AxiosPromise<Array<{ [key: string]: any }>> {
      return localVarFp
        .realmClientsIdScopeMappingsClientsClientCompositeGet(
          realm,
          id,
          client,
          briefRepresentation,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Remove client-level roles from the client’s scope.
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} client
     * @param {Array<RoleRepresentation>} roleRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdScopeMappingsClientsClientDelete(
      realm: string,
      id: string,
      client: string,
      roleRepresentation: Array<RoleRepresentation>,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmClientsIdScopeMappingsClientsClientDelete(
          realm,
          id,
          client,
          roleRepresentation,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get the roles associated with a client’s scope   Returns roles for the client.
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} client
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdScopeMappingsClientsClientGet(
      realm: string,
      id: string,
      client: string,
      options?: any
    ): AxiosPromise<Array<{ [key: string]: any }>> {
      return localVarFp
        .realmClientsIdScopeMappingsClientsClientGet(realm, id, client, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Add client-level roles to the client’s scope
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {string} client
     * @param {Array<RoleRepresentation>} roleRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdScopeMappingsClientsClientPost(
      realm: string,
      id: string,
      client: string,
      roleRepresentation: Array<RoleRepresentation>,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmClientsIdScopeMappingsClientsClientPost(
          realm,
          id,
          client,
          roleRepresentation,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get realm-level roles that are available to attach to this client’s scope
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdScopeMappingsRealmAvailableGet(
      realm: string,
      id: string,
      options?: any
    ): AxiosPromise<Array<{ [key: string]: any }>> {
      return localVarFp
        .realmClientsIdScopeMappingsRealmAvailableGet(realm, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get effective realm-level roles associated with the client’s scope   What this does is recurse  any composite roles associated with the client’s scope and adds the roles to this lists.
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {boolean} [briefRepresentation] if false, return roles with their attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdScopeMappingsRealmCompositeGet(
      realm: string,
      id: string,
      briefRepresentation?: boolean,
      options?: any
    ): AxiosPromise<Array<{ [key: string]: any }>> {
      return localVarFp
        .realmClientsIdScopeMappingsRealmCompositeGet(
          realm,
          id,
          briefRepresentation,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Remove a set of realm-level roles from the client’s scope
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {Array<RoleRepresentation>} roleRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdScopeMappingsRealmDelete(
      realm: string,
      id: string,
      roleRepresentation: Array<RoleRepresentation>,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmClientsIdScopeMappingsRealmDelete(
          realm,
          id,
          roleRepresentation,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get realm-level roles associated with the client’s scope
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdScopeMappingsRealmGet(
      realm: string,
      id: string,
      options?: any
    ): AxiosPromise<Array<{ [key: string]: any }>> {
      return localVarFp
        .realmClientsIdScopeMappingsRealmGet(realm, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Add a set of realm-level roles to the client’s scope
     * @param {string} realm realm name (not id!)
     * @param {string} id id of client (not client-id)
     * @param {Array<RoleRepresentation>} roleRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmClientsIdScopeMappingsRealmPost(
      realm: string,
      id: string,
      roleRepresentation: Array<RoleRepresentation>,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmClientsIdScopeMappingsRealmPost(
          realm,
          id,
          roleRepresentation,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ScopeMappingsApi - object-oriented interface
 * @export
 * @class ScopeMappingsApi
 * @extends {BaseAPI}
 */
export class ScopeMappingsApi extends BaseAPI {
  /**
   *
   * @summary The available client-level roles   Returns the roles for the client that can be associated with the client’s scope
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client scope (not name)
   * @param {string} client
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScopeMappingsApi
   */
  public realmClientScopesIdScopeMappingsClientsClientAvailableGet(
    realm: string,
    id: string,
    client: string,
    options?: AxiosRequestConfig
  ) {
    return ScopeMappingsApiFp(this.configuration)
      .realmClientScopesIdScopeMappingsClientsClientAvailableGet(
        realm,
        id,
        client,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get effective client roles   Returns the roles for the client that are associated with the client’s scope.
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client scope (not name)
   * @param {string} client
   * @param {boolean} [briefRepresentation] if false, return roles with their attributes
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScopeMappingsApi
   */
  public realmClientScopesIdScopeMappingsClientsClientCompositeGet(
    realm: string,
    id: string,
    client: string,
    briefRepresentation?: boolean,
    options?: AxiosRequestConfig
  ) {
    return ScopeMappingsApiFp(this.configuration)
      .realmClientScopesIdScopeMappingsClientsClientCompositeGet(
        realm,
        id,
        client,
        briefRepresentation,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Remove client-level roles from the client’s scope.
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client scope (not name)
   * @param {string} client
   * @param {Array<RoleRepresentation>} roleRepresentation
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScopeMappingsApi
   */
  public realmClientScopesIdScopeMappingsClientsClientDelete(
    realm: string,
    id: string,
    client: string,
    roleRepresentation: Array<RoleRepresentation>,
    options?: AxiosRequestConfig
  ) {
    return ScopeMappingsApiFp(this.configuration)
      .realmClientScopesIdScopeMappingsClientsClientDelete(
        realm,
        id,
        client,
        roleRepresentation,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get the roles associated with a client’s scope   Returns roles for the client.
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client scope (not name)
   * @param {string} client
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScopeMappingsApi
   */
  public realmClientScopesIdScopeMappingsClientsClientGet(
    realm: string,
    id: string,
    client: string,
    options?: AxiosRequestConfig
  ) {
    return ScopeMappingsApiFp(this.configuration)
      .realmClientScopesIdScopeMappingsClientsClientGet(
        realm,
        id,
        client,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Add client-level roles to the client’s scope
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client scope (not name)
   * @param {string} client
   * @param {Array<RoleRepresentation>} roleRepresentation
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScopeMappingsApi
   */
  public realmClientScopesIdScopeMappingsClientsClientPost(
    realm: string,
    id: string,
    client: string,
    roleRepresentation: Array<RoleRepresentation>,
    options?: AxiosRequestConfig
  ) {
    return ScopeMappingsApiFp(this.configuration)
      .realmClientScopesIdScopeMappingsClientsClientPost(
        realm,
        id,
        client,
        roleRepresentation,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get realm-level roles that are available to attach to this client’s scope
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client scope (not name)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScopeMappingsApi
   */
  public realmClientScopesIdScopeMappingsRealmAvailableGet(
    realm: string,
    id: string,
    options?: AxiosRequestConfig
  ) {
    return ScopeMappingsApiFp(this.configuration)
      .realmClientScopesIdScopeMappingsRealmAvailableGet(realm, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get effective realm-level roles associated with the client’s scope   What this does is recurse  any composite roles associated with the client’s scope and adds the roles to this lists.
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client scope (not name)
   * @param {boolean} [briefRepresentation] if false, return roles with their attributes
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScopeMappingsApi
   */
  public realmClientScopesIdScopeMappingsRealmCompositeGet(
    realm: string,
    id: string,
    briefRepresentation?: boolean,
    options?: AxiosRequestConfig
  ) {
    return ScopeMappingsApiFp(this.configuration)
      .realmClientScopesIdScopeMappingsRealmCompositeGet(
        realm,
        id,
        briefRepresentation,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Remove a set of realm-level roles from the client’s scope
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client scope (not name)
   * @param {Array<RoleRepresentation>} roleRepresentation
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScopeMappingsApi
   */
  public realmClientScopesIdScopeMappingsRealmDelete(
    realm: string,
    id: string,
    roleRepresentation: Array<RoleRepresentation>,
    options?: AxiosRequestConfig
  ) {
    return ScopeMappingsApiFp(this.configuration)
      .realmClientScopesIdScopeMappingsRealmDelete(
        realm,
        id,
        roleRepresentation,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get realm-level roles associated with the client’s scope
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client scope (not name)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScopeMappingsApi
   */
  public realmClientScopesIdScopeMappingsRealmGet(
    realm: string,
    id: string,
    options?: AxiosRequestConfig
  ) {
    return ScopeMappingsApiFp(this.configuration)
      .realmClientScopesIdScopeMappingsRealmGet(realm, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Add a set of realm-level roles to the client’s scope
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client scope (not name)
   * @param {Array<RoleRepresentation>} roleRepresentation
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScopeMappingsApi
   */
  public realmClientScopesIdScopeMappingsRealmPost(
    realm: string,
    id: string,
    roleRepresentation: Array<RoleRepresentation>,
    options?: AxiosRequestConfig
  ) {
    return ScopeMappingsApiFp(this.configuration)
      .realmClientScopesIdScopeMappingsRealmPost(
        realm,
        id,
        roleRepresentation,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary The available client-level roles   Returns the roles for the client that can be associated with the client’s scope
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client (not client-id)
   * @param {string} client
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScopeMappingsApi
   */
  public realmClientsIdScopeMappingsClientsClientAvailableGet(
    realm: string,
    id: string,
    client: string,
    options?: AxiosRequestConfig
  ) {
    return ScopeMappingsApiFp(this.configuration)
      .realmClientsIdScopeMappingsClientsClientAvailableGet(
        realm,
        id,
        client,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get effective client roles   Returns the roles for the client that are associated with the client’s scope.
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client (not client-id)
   * @param {string} client
   * @param {boolean} [briefRepresentation] if false, return roles with their attributes
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScopeMappingsApi
   */
  public realmClientsIdScopeMappingsClientsClientCompositeGet(
    realm: string,
    id: string,
    client: string,
    briefRepresentation?: boolean,
    options?: AxiosRequestConfig
  ) {
    return ScopeMappingsApiFp(this.configuration)
      .realmClientsIdScopeMappingsClientsClientCompositeGet(
        realm,
        id,
        client,
        briefRepresentation,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Remove client-level roles from the client’s scope.
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client (not client-id)
   * @param {string} client
   * @param {Array<RoleRepresentation>} roleRepresentation
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScopeMappingsApi
   */
  public realmClientsIdScopeMappingsClientsClientDelete(
    realm: string,
    id: string,
    client: string,
    roleRepresentation: Array<RoleRepresentation>,
    options?: AxiosRequestConfig
  ) {
    return ScopeMappingsApiFp(this.configuration)
      .realmClientsIdScopeMappingsClientsClientDelete(
        realm,
        id,
        client,
        roleRepresentation,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get the roles associated with a client’s scope   Returns roles for the client.
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client (not client-id)
   * @param {string} client
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScopeMappingsApi
   */
  public realmClientsIdScopeMappingsClientsClientGet(
    realm: string,
    id: string,
    client: string,
    options?: AxiosRequestConfig
  ) {
    return ScopeMappingsApiFp(this.configuration)
      .realmClientsIdScopeMappingsClientsClientGet(realm, id, client, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Add client-level roles to the client’s scope
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client (not client-id)
   * @param {string} client
   * @param {Array<RoleRepresentation>} roleRepresentation
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScopeMappingsApi
   */
  public realmClientsIdScopeMappingsClientsClientPost(
    realm: string,
    id: string,
    client: string,
    roleRepresentation: Array<RoleRepresentation>,
    options?: AxiosRequestConfig
  ) {
    return ScopeMappingsApiFp(this.configuration)
      .realmClientsIdScopeMappingsClientsClientPost(
        realm,
        id,
        client,
        roleRepresentation,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get realm-level roles that are available to attach to this client’s scope
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client (not client-id)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScopeMappingsApi
   */
  public realmClientsIdScopeMappingsRealmAvailableGet(
    realm: string,
    id: string,
    options?: AxiosRequestConfig
  ) {
    return ScopeMappingsApiFp(this.configuration)
      .realmClientsIdScopeMappingsRealmAvailableGet(realm, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get effective realm-level roles associated with the client’s scope   What this does is recurse  any composite roles associated with the client’s scope and adds the roles to this lists.
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client (not client-id)
   * @param {boolean} [briefRepresentation] if false, return roles with their attributes
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScopeMappingsApi
   */
  public realmClientsIdScopeMappingsRealmCompositeGet(
    realm: string,
    id: string,
    briefRepresentation?: boolean,
    options?: AxiosRequestConfig
  ) {
    return ScopeMappingsApiFp(this.configuration)
      .realmClientsIdScopeMappingsRealmCompositeGet(
        realm,
        id,
        briefRepresentation,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Remove a set of realm-level roles from the client’s scope
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client (not client-id)
   * @param {Array<RoleRepresentation>} roleRepresentation
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScopeMappingsApi
   */
  public realmClientsIdScopeMappingsRealmDelete(
    realm: string,
    id: string,
    roleRepresentation: Array<RoleRepresentation>,
    options?: AxiosRequestConfig
  ) {
    return ScopeMappingsApiFp(this.configuration)
      .realmClientsIdScopeMappingsRealmDelete(
        realm,
        id,
        roleRepresentation,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get realm-level roles associated with the client’s scope
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client (not client-id)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScopeMappingsApi
   */
  public realmClientsIdScopeMappingsRealmGet(
    realm: string,
    id: string,
    options?: AxiosRequestConfig
  ) {
    return ScopeMappingsApiFp(this.configuration)
      .realmClientsIdScopeMappingsRealmGet(realm, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Add a set of realm-level roles to the client’s scope
   * @param {string} realm realm name (not id!)
   * @param {string} id id of client (not client-id)
   * @param {Array<RoleRepresentation>} roleRepresentation
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScopeMappingsApi
   */
  public realmClientsIdScopeMappingsRealmPost(
    realm: string,
    id: string,
    roleRepresentation: Array<RoleRepresentation>,
    options?: AxiosRequestConfig
  ) {
    return ScopeMappingsApiFp(this.configuration)
      .realmClientsIdScopeMappingsRealmPost(
        realm,
        id,
        roleRepresentation,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}
