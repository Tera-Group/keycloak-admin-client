/* tslint:disable */
/* eslint-disable */
/**
 * Keycloak Admin REST API
 * This is a REST API reference for the Keycloak Admin REST API.
 *
 * The version of the OpenAPI document: 1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from '../common';
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from '../base';
// @ts-ignore
import { GroupRepresentation } from '../model';
// @ts-ignore
import { ManagementPermissionReference } from '../model';
/**
 * GroupsApi - axios parameter creator
 * @export
 */
export const GroupsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Returns the groups counts.
     * @param {string} realm realm name (not id!)
     * @param {string} [search]
     * @param {boolean} [top]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmGroupsCountGet: async (
      realm: string,
      search?: string,
      top?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmGroupsCountGet', 'realm', realm);
      const localVarPath = `/{realm}/groups/count`.replace(
        `{${'realm'}}`,
        encodeURIComponent(String(realm))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (search !== undefined) {
        localVarQueryParameter['search'] = search;
      }

      if (top !== undefined) {
        localVarQueryParameter['top'] = top;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get group hierarchy.
     * @param {string} realm realm name (not id!)
     * @param {boolean} [briefRepresentation]
     * @param {number} [first]
     * @param {number} [max]
     * @param {string} [search]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmGroupsGet: async (
      realm: string,
      briefRepresentation?: boolean,
      first?: number,
      max?: number,
      search?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmGroupsGet', 'realm', realm);
      const localVarPath = `/{realm}/groups`.replace(
        `{${'realm'}}`,
        encodeURIComponent(String(realm))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (briefRepresentation !== undefined) {
        localVarQueryParameter['briefRepresentation'] = briefRepresentation;
      }

      if (first !== undefined) {
        localVarQueryParameter['first'] = first;
      }

      if (max !== undefined) {
        localVarQueryParameter['max'] = max;
      }

      if (search !== undefined) {
        localVarQueryParameter['search'] = search;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Set or create child.
     * @param {string} realm realm name (not id!)
     * @param {string} id
     * @param {GroupRepresentation} groupRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmGroupsIdChildrenPost: async (
      realm: string,
      id: string,
      groupRepresentation: GroupRepresentation,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmGroupsIdChildrenPost', 'realm', realm);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmGroupsIdChildrenPost', 'id', id);
      // verify required parameter 'groupRepresentation' is not null or undefined
      assertParamExists(
        'realmGroupsIdChildrenPost',
        'groupRepresentation',
        groupRepresentation
      );
      const localVarPath = `/{realm}/groups/{id}/children`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        groupRepresentation,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmGroupsIdDelete: async (
      realm: string,
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmGroupsIdDelete', 'realm', realm);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmGroupsIdDelete', 'id', id);
      const localVarPath = `/{realm}/groups/{id}`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmGroupsIdGet: async (
      realm: string,
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmGroupsIdGet', 'realm', realm);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmGroupsIdGet', 'id', id);
      const localVarPath = `/{realm}/groups/{id}`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Return object stating whether client Authorization permissions have been initialized or not and a reference
     * @param {string} realm realm name (not id!)
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmGroupsIdManagementPermissionsGet: async (
      realm: string,
      id: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmGroupsIdManagementPermissionsGet',
        'realm',
        realm
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmGroupsIdManagementPermissionsGet', 'id', id);
      const localVarPath = `/{realm}/groups/{id}/management/permissions`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Return object stating whether client Authorization permissions have been initialized or not and a reference
     * @param {string} realm realm name (not id!)
     * @param {string} id
     * @param {ManagementPermissionReference} managementPermissionReference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmGroupsIdManagementPermissionsPut: async (
      realm: string,
      id: string,
      managementPermissionReference: ManagementPermissionReference,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists(
        'realmGroupsIdManagementPermissionsPut',
        'realm',
        realm
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmGroupsIdManagementPermissionsPut', 'id', id);
      // verify required parameter 'managementPermissionReference' is not null or undefined
      assertParamExists(
        'realmGroupsIdManagementPermissionsPut',
        'managementPermissionReference',
        managementPermissionReference
      );
      const localVarPath = `/{realm}/groups/{id}/management/permissions`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        managementPermissionReference,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get users   Returns a stream of users, filtered according to query parameters
     * @param {string} realm realm name (not id!)
     * @param {string} id
     * @param {boolean} [briefRepresentation] Only return basic information (only guaranteed to return id, username, created, first and last name,  email, enabled state, email verification state, federation link, and access.  Note that it means that namely user attributes, required actions, and not before are not returned.)
     * @param {number} [first] Pagination offset
     * @param {number} [max] Maximum results size (defaults to 100)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmGroupsIdMembersGet: async (
      realm: string,
      id: string,
      briefRepresentation?: boolean,
      first?: number,
      max?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmGroupsIdMembersGet', 'realm', realm);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmGroupsIdMembersGet', 'id', id);
      const localVarPath = `/{realm}/groups/{id}/members`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (briefRepresentation !== undefined) {
        localVarQueryParameter['briefRepresentation'] = briefRepresentation;
      }

      if (first !== undefined) {
        localVarQueryParameter['first'] = first;
      }

      if (max !== undefined) {
        localVarQueryParameter['max'] = max;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update group, ignores subgroups.
     * @param {string} realm realm name (not id!)
     * @param {string} id
     * @param {GroupRepresentation} groupRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmGroupsIdPut: async (
      realm: string,
      id: string,
      groupRepresentation: GroupRepresentation,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmGroupsIdPut', 'realm', realm);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('realmGroupsIdPut', 'id', id);
      // verify required parameter 'groupRepresentation' is not null or undefined
      assertParamExists(
        'realmGroupsIdPut',
        'groupRepresentation',
        groupRepresentation
      );
      const localVarPath = `/{realm}/groups/{id}`
        .replace(`{${'realm'}}`, encodeURIComponent(String(realm)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        groupRepresentation,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary create or add a top level realm groupSet or create child.
     * @param {string} realm realm name (not id!)
     * @param {GroupRepresentation} groupRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmGroupsPost: async (
      realm: string,
      groupRepresentation: GroupRepresentation,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'realm' is not null or undefined
      assertParamExists('realmGroupsPost', 'realm', realm);
      // verify required parameter 'groupRepresentation' is not null or undefined
      assertParamExists(
        'realmGroupsPost',
        'groupRepresentation',
        groupRepresentation
      );
      const localVarPath = `/{realm}/groups`.replace(
        `{${'realm'}}`,
        encodeURIComponent(String(realm))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication access_token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        groupRepresentation,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * GroupsApi - functional programming interface
 * @export
 */
export const GroupsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = GroupsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Returns the groups counts.
     * @param {string} realm realm name (not id!)
     * @param {string} [search]
     * @param {boolean} [top]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmGroupsCountGet(
      realm: string,
      search?: string,
      top?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: any }>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmGroupsCountGet(
          realm,
          search,
          top,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get group hierarchy.
     * @param {string} realm realm name (not id!)
     * @param {boolean} [briefRepresentation]
     * @param {number} [first]
     * @param {number} [max]
     * @param {string} [search]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmGroupsGet(
      realm: string,
      briefRepresentation?: boolean,
      first?: number,
      max?: number,
      search?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<{ [key: string]: any }>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.realmGroupsGet(
        realm,
        briefRepresentation,
        first,
        max,
        search,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Set or create child.
     * @param {string} realm realm name (not id!)
     * @param {string} id
     * @param {GroupRepresentation} groupRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmGroupsIdChildrenPost(
      realm: string,
      id: string,
      groupRepresentation: GroupRepresentation,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmGroupsIdChildrenPost(
          realm,
          id,
          groupRepresentation,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmGroupsIdDelete(
      realm: string,
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmGroupsIdDelete(realm, id, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmGroupsIdGet(
      realm: string,
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GroupRepresentation>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmGroupsIdGet(realm, id, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Return object stating whether client Authorization permissions have been initialized or not and a reference
     * @param {string} realm realm name (not id!)
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmGroupsIdManagementPermissionsGet(
      realm: string,
      id: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ManagementPermissionReference>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmGroupsIdManagementPermissionsGet(
          realm,
          id,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Return object stating whether client Authorization permissions have been initialized or not and a reference
     * @param {string} realm realm name (not id!)
     * @param {string} id
     * @param {ManagementPermissionReference} managementPermissionReference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmGroupsIdManagementPermissionsPut(
      realm: string,
      id: string,
      managementPermissionReference: ManagementPermissionReference,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ManagementPermissionReference>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmGroupsIdManagementPermissionsPut(
          realm,
          id,
          managementPermissionReference,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get users   Returns a stream of users, filtered according to query parameters
     * @param {string} realm realm name (not id!)
     * @param {string} id
     * @param {boolean} [briefRepresentation] Only return basic information (only guaranteed to return id, username, created, first and last name,  email, enabled state, email verification state, federation link, and access.  Note that it means that namely user attributes, required actions, and not before are not returned.)
     * @param {number} [first] Pagination offset
     * @param {number} [max] Maximum results size (defaults to 100)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmGroupsIdMembersGet(
      realm: string,
      id: string,
      briefRepresentation?: boolean,
      first?: number,
      max?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<{ [key: string]: any }>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmGroupsIdMembersGet(
          realm,
          id,
          briefRepresentation,
          first,
          max,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Update group, ignores subgroups.
     * @param {string} realm realm name (not id!)
     * @param {string} id
     * @param {GroupRepresentation} groupRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmGroupsIdPut(
      realm: string,
      id: string,
      groupRepresentation: GroupRepresentation,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.realmGroupsIdPut(
          realm,
          id,
          groupRepresentation,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary create or add a top level realm groupSet or create child.
     * @param {string} realm realm name (not id!)
     * @param {GroupRepresentation} groupRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async realmGroupsPost(
      realm: string,
      groupRepresentation: GroupRepresentation,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.realmGroupsPost(
        realm,
        groupRepresentation,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * GroupsApi - factory interface
 * @export
 */
export const GroupsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = GroupsApiFp(configuration);
  return {
    /**
     *
     * @summary Returns the groups counts.
     * @param {string} realm realm name (not id!)
     * @param {string} [search]
     * @param {boolean} [top]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmGroupsCountGet(
      realm: string,
      search?: string,
      top?: boolean,
      options?: any
    ): AxiosPromise<{ [key: string]: any }> {
      return localVarFp
        .realmGroupsCountGet(realm, search, top, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get group hierarchy.
     * @param {string} realm realm name (not id!)
     * @param {boolean} [briefRepresentation]
     * @param {number} [first]
     * @param {number} [max]
     * @param {string} [search]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmGroupsGet(
      realm: string,
      briefRepresentation?: boolean,
      first?: number,
      max?: number,
      search?: string,
      options?: any
    ): AxiosPromise<Array<{ [key: string]: any }>> {
      return localVarFp
        .realmGroupsGet(realm, briefRepresentation, first, max, search, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Set or create child.
     * @param {string} realm realm name (not id!)
     * @param {string} id
     * @param {GroupRepresentation} groupRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmGroupsIdChildrenPost(
      realm: string,
      id: string,
      groupRepresentation: GroupRepresentation,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmGroupsIdChildrenPost(realm, id, groupRepresentation, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmGroupsIdDelete(
      realm: string,
      id: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmGroupsIdDelete(realm, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} realm realm name (not id!)
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmGroupsIdGet(
      realm: string,
      id: string,
      options?: any
    ): AxiosPromise<GroupRepresentation> {
      return localVarFp
        .realmGroupsIdGet(realm, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Return object stating whether client Authorization permissions have been initialized or not and a reference
     * @param {string} realm realm name (not id!)
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmGroupsIdManagementPermissionsGet(
      realm: string,
      id: string,
      options?: any
    ): AxiosPromise<ManagementPermissionReference> {
      return localVarFp
        .realmGroupsIdManagementPermissionsGet(realm, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Return object stating whether client Authorization permissions have been initialized or not and a reference
     * @param {string} realm realm name (not id!)
     * @param {string} id
     * @param {ManagementPermissionReference} managementPermissionReference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmGroupsIdManagementPermissionsPut(
      realm: string,
      id: string,
      managementPermissionReference: ManagementPermissionReference,
      options?: any
    ): AxiosPromise<ManagementPermissionReference> {
      return localVarFp
        .realmGroupsIdManagementPermissionsPut(
          realm,
          id,
          managementPermissionReference,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get users   Returns a stream of users, filtered according to query parameters
     * @param {string} realm realm name (not id!)
     * @param {string} id
     * @param {boolean} [briefRepresentation] Only return basic information (only guaranteed to return id, username, created, first and last name,  email, enabled state, email verification state, federation link, and access.  Note that it means that namely user attributes, required actions, and not before are not returned.)
     * @param {number} [first] Pagination offset
     * @param {number} [max] Maximum results size (defaults to 100)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmGroupsIdMembersGet(
      realm: string,
      id: string,
      briefRepresentation?: boolean,
      first?: number,
      max?: number,
      options?: any
    ): AxiosPromise<Array<{ [key: string]: any }>> {
      return localVarFp
        .realmGroupsIdMembersGet(
          realm,
          id,
          briefRepresentation,
          first,
          max,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update group, ignores subgroups.
     * @param {string} realm realm name (not id!)
     * @param {string} id
     * @param {GroupRepresentation} groupRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmGroupsIdPut(
      realm: string,
      id: string,
      groupRepresentation: GroupRepresentation,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmGroupsIdPut(realm, id, groupRepresentation, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary create or add a top level realm groupSet or create child.
     * @param {string} realm realm name (not id!)
     * @param {GroupRepresentation} groupRepresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    realmGroupsPost(
      realm: string,
      groupRepresentation: GroupRepresentation,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .realmGroupsPost(realm, groupRepresentation, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
export class GroupsApi extends BaseAPI {
  /**
   *
   * @summary Returns the groups counts.
   * @param {string} realm realm name (not id!)
   * @param {string} [search]
   * @param {boolean} [top]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GroupsApi
   */
  public realmGroupsCountGet(
    realm: string,
    search?: string,
    top?: boolean,
    options?: AxiosRequestConfig
  ) {
    return GroupsApiFp(this.configuration)
      .realmGroupsCountGet(realm, search, top, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get group hierarchy.
   * @param {string} realm realm name (not id!)
   * @param {boolean} [briefRepresentation]
   * @param {number} [first]
   * @param {number} [max]
   * @param {string} [search]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GroupsApi
   */
  public realmGroupsGet(
    realm: string,
    briefRepresentation?: boolean,
    first?: number,
    max?: number,
    search?: string,
    options?: AxiosRequestConfig
  ) {
    return GroupsApiFp(this.configuration)
      .realmGroupsGet(realm, briefRepresentation, first, max, search, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Set or create child.
   * @param {string} realm realm name (not id!)
   * @param {string} id
   * @param {GroupRepresentation} groupRepresentation
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GroupsApi
   */
  public realmGroupsIdChildrenPost(
    realm: string,
    id: string,
    groupRepresentation: GroupRepresentation,
    options?: AxiosRequestConfig
  ) {
    return GroupsApiFp(this.configuration)
      .realmGroupsIdChildrenPost(realm, id, groupRepresentation, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} realm realm name (not id!)
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GroupsApi
   */
  public realmGroupsIdDelete(
    realm: string,
    id: string,
    options?: AxiosRequestConfig
  ) {
    return GroupsApiFp(this.configuration)
      .realmGroupsIdDelete(realm, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} realm realm name (not id!)
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GroupsApi
   */
  public realmGroupsIdGet(
    realm: string,
    id: string,
    options?: AxiosRequestConfig
  ) {
    return GroupsApiFp(this.configuration)
      .realmGroupsIdGet(realm, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Return object stating whether client Authorization permissions have been initialized or not and a reference
   * @param {string} realm realm name (not id!)
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GroupsApi
   */
  public realmGroupsIdManagementPermissionsGet(
    realm: string,
    id: string,
    options?: AxiosRequestConfig
  ) {
    return GroupsApiFp(this.configuration)
      .realmGroupsIdManagementPermissionsGet(realm, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Return object stating whether client Authorization permissions have been initialized or not and a reference
   * @param {string} realm realm name (not id!)
   * @param {string} id
   * @param {ManagementPermissionReference} managementPermissionReference
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GroupsApi
   */
  public realmGroupsIdManagementPermissionsPut(
    realm: string,
    id: string,
    managementPermissionReference: ManagementPermissionReference,
    options?: AxiosRequestConfig
  ) {
    return GroupsApiFp(this.configuration)
      .realmGroupsIdManagementPermissionsPut(
        realm,
        id,
        managementPermissionReference,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get users   Returns a stream of users, filtered according to query parameters
   * @param {string} realm realm name (not id!)
   * @param {string} id
   * @param {boolean} [briefRepresentation] Only return basic information (only guaranteed to return id, username, created, first and last name,  email, enabled state, email verification state, federation link, and access.  Note that it means that namely user attributes, required actions, and not before are not returned.)
   * @param {number} [first] Pagination offset
   * @param {number} [max] Maximum results size (defaults to 100)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GroupsApi
   */
  public realmGroupsIdMembersGet(
    realm: string,
    id: string,
    briefRepresentation?: boolean,
    first?: number,
    max?: number,
    options?: AxiosRequestConfig
  ) {
    return GroupsApiFp(this.configuration)
      .realmGroupsIdMembersGet(
        realm,
        id,
        briefRepresentation,
        first,
        max,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update group, ignores subgroups.
   * @param {string} realm realm name (not id!)
   * @param {string} id
   * @param {GroupRepresentation} groupRepresentation
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GroupsApi
   */
  public realmGroupsIdPut(
    realm: string,
    id: string,
    groupRepresentation: GroupRepresentation,
    options?: AxiosRequestConfig
  ) {
    return GroupsApiFp(this.configuration)
      .realmGroupsIdPut(realm, id, groupRepresentation, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary create or add a top level realm groupSet or create child.
   * @param {string} realm realm name (not id!)
   * @param {GroupRepresentation} groupRepresentation
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GroupsApi
   */
  public realmGroupsPost(
    realm: string,
    groupRepresentation: GroupRepresentation,
    options?: AxiosRequestConfig
  ) {
    return GroupsApiFp(this.configuration)
      .realmGroupsPost(realm, groupRepresentation, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
